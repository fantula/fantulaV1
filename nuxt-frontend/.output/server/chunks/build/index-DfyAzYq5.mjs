export { default as dayjs } from 'dayjs';
import { t as teleportProps } from './focus-trap-D_6Xxduc.mjs';
import { U as UPDATE_MODEL_EVENT, C as CHANGE_EVENT } from './event-BZTOGHfp.mjs';
export { I as INPUT_EVENT } from './event-BZTOGHfp.mjs';
import { q as buildProps, D as definePropType, aw as iconPropType, x as useNamespace, E as ElIcon, ag as check_default, l as loading_default, f as arrow_right_default, y as useLocale, S as useId, w as _export_sfc$1, B as withInstall, aY as useEmptyValuesProps, a_ as circle_close_default, ax as useSizeProp, F as mutable, W as EVENT_CODE, bQ as back_default, aD as isBoolean$1, T as addUnit, bR as withInstallDirective, b1 as star_filled_default, a8 as star_default, aC as buildProp, aR as componentSizes, r as isNumber$1, A as isUndefined$1, aN as clock_default, bP as caret_right_default, J as close_default, aX as isEmpty, V as getEventCode, bs as isPropAbsent, aM as removeClass, Z as addClass, bT as sort_up_default, bU as sort_down_default } from './server.mjs';
export { cg as DEFAULT_EMPTY_VALUES, ch as DEFAULT_VALUE_ON_CLEAR, bW as ElBadge, ah as ElMessage, ca as ID_INJECTION_KEY, c0 as MESSAGE_DEFAULT_PLACEMENT, ci as SCOPE, cf as SIZE_INJECTION_KEY, cc as ZINDEX_INJECTION_KEY, bV as badgeProps, c6 as buildLocaleContext, c7 as buildTranslator, bZ as configProviderContextKey, bY as configProviderProps, cd as defaultInitialZIndex, bE as defaultNamespace, cj as emptyValuesContextKey, b$ as iconProps, c8 as localeContextKey, bX as messageConfig, c1 as messageDefaults, c2 as messageEmits, c3 as messagePlacement, c4 as messageProps, c5 as messageTypes, cb as namespaceContextKey, b_ as provideGlobalConfig, c9 as translate, aV as useEmptyValues, aF as useGetDerivedNamespace, aL as useGlobalComponentSettings, av as useGlobalConfig, ay as useGlobalSize, aG as useIdInjection, I as useZIndex, ce as zIndexContextKey } from './server.mjs';
export { E as ElAlert, a as alertEffects, b as alertEmits, c as alertProps } from './index-DvOrIhmd.mjs';
import { i as inputProps } from './index-Bf1ETwA6.mjs';
export { E as ElInput, b as inputEmits, u as useComposition, c as useCursor, a as useFocusController } from './index-Bf1ETwA6.mjs';
import { u as useTooltipContentProps, a as useTooltipTriggerProps, E as ElTooltip, b as unique, c as castArray$1 } from './index-CIoWkt90.mjs';
export { d as ElPopper, f as ElPopperArrow, g as ElPopperContent, h as ElPopperTrigger, F as FORWARD_REF_INJECTION_KEY, P as POPPER_CONTENT_INJECTION_KEY, i as POPPER_INJECTION_KEY, T as TOOLTIP_INJECTION_KEY, j as createModelToggleComposable, p as popperArrowProps, k as popperContentEmits, l as popperContentProps, m as popperCoreConfigProps, n as popperProps, o as popperTriggerProps, r as roleTypes, t as tooltipEmits, q as useDelayedToggle, s as useDelayedToggleProps, v as useForwardRef, w as useForwardRefDirective, x as usePopper, y as usePopperContainer, z as usePopperContainerId, A as useTimeout, B as useTooltipModelToggle, C as useTooltipModelToggleEmits, D as useTooltipModelToggleProps, G as useTooltipProps } from './index-CIoWkt90.mjs';
import { NOOP, isArray, isString, isFunction, isDate, hasOwn, isObject } from '@vue/shared';
export { E as ElAvatar, a as avatarEmits, b as avatarGroupContextKey, c as avatarGroupProps, d as avatarProps } from './index-C2DKVZ9g.mjs';
export { E as ElButton, a as buttonEmits, c as buttonGroupContextKey, d as buttonNativeTypes, e as buttonProps, b as buttonTypes } from './index-DR2tYDZ3.mjs';
export { E as ElCard, c as cardProps } from './index-9Hs_9io2.mjs';
export { C as CAROUSEL_ITEM_NAME, E as ElCarousel, a as ElCarouselItem, c as carouselContextKey, b as carouselEmits, d as carouselItemProps, e as carouselProps } from './index-6l5oVPy9.mjs';
import { placements } from '@popperjs/core';
import { defineComponent, inject, createVNode, computed, createElementBlock, openBlock, normalizeClass, unref, createCommentVNode, createBlock, withModifiers, withCtx, createElementVNode, Fragment, getCurrentInstance, ref, renderList, createTextVNode, toDisplayString, renderSlot, useSlots, provide, reactive, watch, mergeProps, h, isVNode, resolveDynamicComponent, normalizeStyle, nextTick, watchEffect, Comment, toRef, shallowRef, resolveComponent, withDirectives, vShow } from 'vue';
import { t as tagProps } from './index-BOQJCp53.mjs';
export { E as ElTag, a as tagEmits } from './index-BOQJCp53.mjs';
import { isEqual, castArray, flattenDeep, cloneDeep, isNil, memoize, debounce, get } from 'lodash-unified';
import { E as ElScrollbar, B as BAR_MAP } from './index-D_b573Qt.mjs';
export { G as GAP, r as renderThumbStyle, a as scrollbarContextKey, s as scrollbarEmits, b as scrollbarProps, t as thumbProps } from './index-D_b573Qt.mjs';
import { E as ElCheckbox } from './index-BlpH41lu.mjs';
export { a as ElCheckboxGroup, c as checkboxDefaultProps, b as checkboxEmits, d as checkboxGroupContextKey, e as checkboxGroupEmits, f as checkboxGroupProps, g as checkboxProps } from './index-BlpH41lu.mjs';
import { b as ElRadio } from './index-5s1BkUoL.mjs';
export { a as ElRadioButton, E as ElRadioGroup, r as radioButtonProps, c as radioDefaultProps, d as radioEmits, e as radioGroupEmits, f as radioGroupKey, g as radioGroupProps, h as radioProps, i as radioPropsBase } from './index-5s1BkUoL.mjs';
import { a as focusNode, g as getSibling, b as isLeaf } from './aria-B8G3G_75.mjs';
import { isClient, useEventListener } from '@vueuse/core';
import { s as scrollIntoView, a as getScrollBarWidth } from './scroll-DcpXtO6O.mjs';
export { a as ElCol, E as ElRow, R as RowAlign, b as RowJustify, c as colProps, r as rowContextKey, d as rowProps } from './index-27bUWc4s.mjs';
import { j as dropdownProps, k as ElCollapseTransition } from './index-CRZxBAEr.mjs';
export { D as DROPDOWN_INJECTION_KEY, l as DROPDOWN_INSTANCE_INJECTION_KEY, a as ElAside, E as ElContainer, f as ElDropdown, h as ElDropdownItem, g as ElDropdownMenu, e as ElHeader, i as ElMain, b as ElMenu, d as ElMenuItem, c as ElSubMenu, M as MENU_INJECTION_KEY, S as SUB_MENU_INJECTION_KEY, m as dropdownItemProps, n as dropdownMenuProps, o as menuEmits, p as menuItemEmits, q as menuItemGroupProps, r as menuItemProps, s as menuProps, t as subMenuProps } from './index-CRZxBAEr.mjs';
export { E as ElColorPicker, a as ElColorPickerPanel, R as ROOT_COMMON_COLOR_INJECTION_KEY, c as colorPickerEmits, b as colorPickerPanelContextKey, d as colorPickerPanelEmits, e as colorPickerPanelProps, f as colorPickerProps } from './index-oLH_ayiP.mjs';
export { C as CommonPicker, D as DEFAULT_FORMATS_DATE, a as DEFAULT_FORMATS_DATEPICKER, b as DEFAULT_FORMATS_TIME, E as ElDatePicker, c as ElDatePickerPanel, P as PICKER_BASE_INJECTION_KEY, d as PICKER_POPPER_OPTIONS_INJECTION_KEY, R as ROOT_COMMON_PICKER_INJECTION_KEY, e as ROOT_PICKER_INJECTION_KEY, f as ROOT_PICKER_IS_DEFAULT_FORMAT_INJECTION_KEY, T as TimePickPanel, g as buildTimeList, h as dateEquals, i as datePickTypes, j as datePickerPanelProps, k as datePickerProps, l as dayOrDaysToDate, m as extractDateFormat, n as extractTimeFormat, o as formatter, p as makeList, q as parseDate, r as rangeArr, t as timePickerDefaultProps, s as timePickerRangeTriggerProps, u as timeUnits, v as valueEquals } from './index-xXDjrfd3.mjs';
export { E as ElDescriptions, a as ElDescriptionsItem, c as columnAlignment, d as descriptionItemProps, b as descriptionProps } from './index-J8thQwNJ.mjs';
export { D as DEFAULT_DIALOG_TRANSITION, E as ElDialog, d as dialogEmits, b as dialogInjectionKey, a as dialogProps, u as useDialog } from './index-CzosOSMt.mjs';
export { E as ElDivider, d as dividerProps } from './index-QnhSR2oe.mjs';
export { E as ElDrawer, d as drawerEmits, a as drawerProps } from './index-Dh4oAC1v.mjs';
import { E as ElEmpty } from './index-DKY_z0U1.mjs';
export { e as emptyProps } from './index-DKY_z0U1.mjs';
export { E as ElForm, a as ElFormItem, f as formEmits, b as formItemProps, c as formItemValidateStates, d as formMetaProps, e as formProps } from './index-B8nHr-W3.mjs';
import { a as formItemContextKey } from './constants-hAKFmBbq.mjs';
export { f as formContextKey } from './constants-hAKFmBbq.mjs';
import { b as useFormSize } from './use-form-common-props-DlCG9pC5.mjs';
export { u as useFormDisabled, a as useFormItem, c as useFormItemInputId, d as useProp } from './use-form-common-props-DlCG9pC5.mjs';
export { E as ElImage, a as ElImageViewer, i as imageEmits, b as imageProps, c as imageViewerEmits, d as imageViewerProps } from './index-Dr3RPaW4.mjs';
export { E as ElInputNumber, i as inputNumberEmits, a as inputNumberProps } from './index-iY4Ojb3q.mjs';
export { E as ElOverlay, o as overlayEmits, b as overlayProps, u as useDraggable, a as useSameTarget } from './index-Dg8Z-nTr.mjs';
export { E as ElPagination, e as elPaginationKey, p as paginationEmits, a as paginationProps } from './index-Da73tUO2.mjs';
export { E as ElPopconfirm, p as popconfirmEmits, a as popconfirmProps } from './index-C6eLVC7y.mjs';
export { a as ElProgress, E as ElUpload, g as genFileId, p as progressProps, u as uploadBaseProps, b as uploadContentProps, c as uploadContextKey, d as uploadDraggerEmits, e as uploadDraggerProps, f as uploadListEmits, h as uploadListProps, i as uploadListTypes, j as uploadProps } from './index-DhXCDWyG.mjs';
import { u as useAriaProps } from './index-Dxw_X3Hq.mjs';
export { a as ariaProps } from './index-Dxw_X3Hq.mjs';
export { a as ElOption, E as ElSelect, M as MINIMUM_INPUT_WIDTH, s as selectGroupKey, b as selectKey, c as selectProps, u as useCalcInputWidth } from './index-pXKVpQSb.mjs';
export { E as ElSkeleton, a as ElSkeletonItem, s as skeletonItemProps, b as skeletonProps, u as useThrottleRender } from './index-BXD0oWDt.mjs';
export { E as ElSlider, s as sliderContextKey, a as sliderEmits, b as sliderProps } from './index-Cz9caq8f.mjs';
import { P as PatchFlags, f as flattedChildren, a as isFragment, b as isValidElementNode } from './vnode-D0IHQw_9.mjs';
export { E as ElStatistic, s as statisticProps } from './index-C-m_XO0-.mjs';
export { a as ElStep, E as ElSteps, S as STEPS_INJECTION_KEY, s as stepProps, b as stepsEmits, c as stepsProps } from './index-BOvktpI5.mjs';
export { E as ElSwitch, s as switchEmits, a as switchProps } from './index-_GccYHgs.mjs';
export { a as ElTable, E as ElTableColumn, M as Mousewheel } from './index-BB44-vTK.mjs';
import { V as VERTICAL, S as ScrollbarDirKey, H as HORIZONTAL, b as SCROLLBAR_MIN_SIZE, I as ITEM_RENDER_EVT, c as SCROLL_EVT, u as useWheel, F as FORWARD, B as BACKWARD, A as AUTO_ALIGNMENT, D as DEFAULT_DYNAMIC_LIST_ITEM_SIZE, C as CENTERED_ALIGNMENT, d as END_ALIGNMENT, e as START_ALIGNMENT, f as SMART_ALIGNMENT, L as LTR, R as RTL, g as RTL_OFFSET_POS_ASC, h as RTL_OFFSET_NAG, i as RTL_OFFSET_POS_DESC } from './index-DghwLlHw.mjs';
export { a as ElTabPane, E as ElTabs, t as tabBarProps, j as tabNavEmits, k as tabNavProps, l as tabPaneProps, m as tabsEmits, n as tabsProps, o as tabsRootContextKey } from './index-DghwLlHw.mjs';
import { c as cAF, r as rAF } from './raf-CQRaPAjg.mjs';
import memoOne from 'memoize-one';
export { v as ElLoadingDirective, L as ElLoadingService, v as vLoading } from './directive-tOiqatq5.mjs';
export { E as ElMessageBox, T as TrapFocus } from './index-Bf6vTHIR.mjs';
export { C as ClickOutside } from './index-DCrMmn3b.mjs';
export { v as vRepeatClick } from './index-DOE061f1.mjs';
export { u as useAttrs } from './index-ClPmkyX9.mjs';
export { u as useDeprecated } from './index-7IYgoTSU.mjs';
export { u as useLockscreen } from './index-B-o0CD59.mjs';
export { u as useOrderedChildren } from './index-BrFCEoKQ.mjs';
import '../nitro/nitro.mjs';
import 'node:http';
import 'node:https';
import 'node:events';
import 'node:buffer';
import 'node:fs';
import 'node:path';
import 'node:crypto';
import 'node:url';
import '../routes/renderer.mjs';
import 'vue-bundle-renderer/runtime';
import 'vue/server-renderer';
import 'unhead/server';
import 'devalue';
import 'unhead/utils';
import 'unhead/plugins';
import 'vue-router';
import '@supabase/supabase-js';
import 'form-data';
import 'crypto';
import 'url';
import 'proxy-from-env';
import 'http';
import 'https';
import 'http2';
import 'util';
import 'follow-redirects';
import 'zlib';
import 'stream';
import 'events';
import '@ctrl/tinycolor';
import './refs-CxYYXu5Q.mjs';
import 'dayjs/plugin/customParseFormat.js';
import 'dayjs/plugin/advancedFormat.js';
import 'dayjs/plugin/localeData.js';
import 'dayjs/plugin/weekOfYear.js';
import 'dayjs/plugin/weekYear.js';
import 'dayjs/plugin/dayOfYear.js';
import 'dayjs/plugin/isSameOrAfter.js';
import 'dayjs/plugin/isSameOrBefore.js';
import 'async-validator';
import './strings-D1uxkXhq.mjs';
import './validator-T0bsmJHo.mjs';
import 'normalize-wheel-es';

buildProps({
  zIndex: {
    type: definePropType([Number, String]),
    default: 100
  },
  target: {
    type: String,
    default: ""
  },
  offset: {
    type: Number,
    default: 0
  },
  position: {
    type: String,
    values: ["top", "bottom"],
    default: "top"
  },
  teleported: Boolean,
  appendTo: {
    type: teleportProps.to.type,
    default: "body"
  }
});
buildProps({
  ...inputProps,
  valueKey: {
    type: String,
    default: "value"
  },
  modelValue: {
    type: [String, Number],
    default: ""
  },
  debounce: {
    type: Number,
    default: 300
  },
  placement: {
    type: definePropType(String),
    values: [
      "top",
      "top-start",
      "top-end",
      "bottom",
      "bottom-start",
      "bottom-end"
    ],
    default: "bottom-start"
  },
  fetchSuggestions: {
    type: definePropType([Function, Array]),
    default: NOOP
  },
  popperClass: useTooltipContentProps.popperClass,
  popperStyle: useTooltipContentProps.popperStyle,
  triggerOnFocus: {
    type: Boolean,
    default: true
  },
  selectWhenUnmatched: Boolean,
  hideLoading: Boolean,
  teleported: useTooltipContentProps.teleported,
  appendTo: useTooltipContentProps.appendTo,
  highlightFirstItem: Boolean,
  fitInputWidth: Boolean,
  loopNavigation: {
    type: Boolean,
    default: true
  }
});
buildProps({
  separator: {
    type: String,
    default: "/"
  },
  separatorIcon: {
    type: iconPropType
  }
});
buildProps({
  to: {
    type: definePropType([String, Object]),
    default: ""
  },
  replace: Boolean
});
const isValidRange = (range) => isArray(range) && range.length === 2 && range.every((item) => isDate(item));
buildProps({
  modelValue: {
    type: Date
  },
  range: {
    type: definePropType(Array),
    validator: isValidRange
  },
  controllerType: {
    type: String,
    values: ["button", "select"],
    default: "button"
  },
  formatter: {
    type: definePropType(Function)
  }
});
const CASCADER_PANEL_INJECTION_KEY = /* @__PURE__ */ Symbol();
function isVNodeEmpty(vnodes) {
  return !!(isArray(vnodes) ? vnodes.every(({
    type
  }) => type === Comment) : (vnodes == null ? void 0 : vnodes.type) === Comment);
}
var NodeContent$1 = defineComponent({
  name: "NodeContent",
  props: {
    node: {
      type: Object,
      required: true
    }
  },
  setup(props) {
    const ns = useNamespace("cascader-node");
    const {
      renderLabelFn
    } = inject(CASCADER_PANEL_INJECTION_KEY);
    const {
      node
    } = props;
    const {
      data,
      label: nodeLabel
    } = node;
    const label = () => {
      const renderLabel = renderLabelFn == null ? void 0 : renderLabelFn({
        node,
        data
      });
      return isVNodeEmpty(renderLabel) ? nodeLabel : renderLabel != null ? renderLabel : nodeLabel;
    };
    return () => createVNode("span", {
      "class": ns.e("label")
    }, [label()]);
  }
});
const _hoisted_1$1 = ["id", "aria-haspopup", "aria-owns", "aria-expanded", "tabindex"];
const _sfc_main$7 = defineComponent({
  ...{
    name: "ElCascaderNode"
  },
  __name: "node",
  props: {
    node: {
      type: Object,
      required: true
    },
    menuId: String
  },
  emits: ["expand"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const panel = inject(CASCADER_PANEL_INJECTION_KEY);
    const ns = useNamespace("cascader-node");
    const isHoverMenu = computed(() => panel.isHoverMenu);
    const multiple = computed(() => panel.config.multiple);
    const checkStrictly = computed(() => panel.config.checkStrictly);
    const showPrefix = computed(() => panel.config.showPrefix);
    const checkedNodeId = computed(() => {
      var _a;
      return (_a = panel.checkedNodes[0]) == null ? void 0 : _a.uid;
    });
    const isDisabled = computed(() => props.node.isDisabled);
    const isLeaf2 = computed(() => props.node.isLeaf);
    const expandable = computed(
      () => checkStrictly.value && !isLeaf2.value || !isDisabled.value
    );
    const inExpandingPath = computed(() => isInPath(panel.expandingNode));
    const inCheckedPath = computed(
      () => checkStrictly.value && panel.checkedNodes.some(isInPath)
    );
    const isInPath = (node) => {
      var _a;
      const { level, uid: uid2 } = props.node;
      return ((_a = node == null ? void 0 : node.pathNodes[level - 1]) == null ? void 0 : _a.uid) === uid2;
    };
    const doExpand = () => {
      if (inExpandingPath.value)
        return;
      panel.expandNode(props.node);
    };
    const doCheck = (checked) => {
      const { node } = props;
      if (checked === node.checked)
        return;
      panel.handleCheckChange(node, checked);
    };
    const doLoad = () => {
      panel.lazyLoad(props.node, () => {
        if (!isLeaf2.value)
          doExpand();
      });
    };
    const handleHoverExpand = (e12) => {
      if (!isHoverMenu.value)
        return;
      handleExpand();
      !isLeaf2.value && emit("expand", e12);
    };
    const handleExpand = () => {
      const { node } = props;
      if (!expandable.value || node.loading)
        return;
      node.loaded ? doExpand() : doLoad();
    };
    const handleClick = () => {
      if (isLeaf2.value && !isDisabled.value && !checkStrictly.value && !multiple.value) {
        handleCheck(true);
      } else if ((panel.config.checkOnClickNode && (multiple.value || checkStrictly.value) || isLeaf2.value && panel.config.checkOnClickLeaf) && !isDisabled.value) {
        handleSelectCheck(!props.node.checked);
      } else if (!isHoverMenu.value) {
        handleExpand();
      }
    };
    const handleSelectCheck = (checked) => {
      if (checkStrictly.value) {
        doCheck(checked);
        if (props.node.loaded) {
          doExpand();
        }
      } else {
        handleCheck(checked);
      }
    };
    const handleCheck = (checked) => {
      if (!props.node.loaded) {
        doLoad();
      } else {
        doCheck(checked);
        !checkStrictly.value && doExpand();
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("li", {
        id: `${__props.menuId}-${__props.node.uid}`,
        role: "menuitem",
        "aria-haspopup": !isLeaf2.value,
        "aria-owns": isLeaf2.value ? void 0 : __props.menuId,
        "aria-expanded": inExpandingPath.value,
        tabindex: expandable.value ? -1 : void 0,
        class: normalizeClass([
          unref(ns).b(),
          unref(ns).is("selectable", checkStrictly.value),
          unref(ns).is("active", __props.node.checked),
          unref(ns).is("disabled", !expandable.value),
          inExpandingPath.value && "in-active-path",
          inCheckedPath.value && "in-checked-path"
        ]),
        onMouseenter: handleHoverExpand,
        onFocus: handleHoverExpand,
        onClick: handleClick
      }, [
        createCommentVNode(" prefix "),
        multiple.value && showPrefix.value ? (openBlock(), createBlock(unref(ElCheckbox), {
          key: 0,
          "model-value": __props.node.checked,
          indeterminate: __props.node.indeterminate,
          disabled: isDisabled.value,
          onClick: _cache[0] || (_cache[0] = withModifiers(() => {
          }, ["stop"])),
          "onUpdate:modelValue": handleSelectCheck
        }, null, 8, ["model-value", "indeterminate", "disabled"])) : checkStrictly.value && showPrefix.value ? (openBlock(), createBlock(unref(ElRadio), {
          key: 1,
          "model-value": checkedNodeId.value,
          label: __props.node.uid,
          disabled: isDisabled.value,
          "onUpdate:modelValue": handleSelectCheck,
          onClick: _cache[1] || (_cache[1] = withModifiers(() => {
          }, ["stop"]))
        }, {
          default: withCtx(() => [
            createCommentVNode("\n        Add an empty element to avoid render label,\n        do not use empty fragment here for https://github.com/vuejs/vue-next/pull/2485\n      "),
            _cache[2] || (_cache[2] = createElementVNode(
              "span",
              null,
              null,
              -1
            ))
          ]),
          _: 1
        }, 8, ["model-value", "label", "disabled"])) : isLeaf2.value && __props.node.checked ? (openBlock(), createBlock(unref(ElIcon), {
          key: 2,
          class: normalizeClass(unref(ns).e("prefix"))
        }, {
          default: withCtx(() => [
            createVNode(unref(check_default))
          ]),
          _: 1
        }, 8, ["class"])) : createCommentVNode("v-if", true),
        createCommentVNode(" content "),
        createVNode(unref(NodeContent$1), { node: __props.node }, null, 8, ["node"]),
        createCommentVNode(" postfix "),
        !isLeaf2.value ? (openBlock(), createElementBlock(
          Fragment,
          { key: 3 },
          [
            __props.node.loading ? (openBlock(), createBlock(unref(ElIcon), {
              key: 0,
              class: normalizeClass([unref(ns).is("loading"), unref(ns).e("postfix")])
            }, {
              default: withCtx(() => [
                createVNode(unref(loading_default))
              ]),
              _: 1
            }, 8, ["class"])) : (openBlock(), createBlock(unref(ElIcon), {
              key: 1,
              class: normalizeClass(["arrow-right", unref(ns).e("postfix")])
            }, {
              default: withCtx(() => [
                createVNode(unref(arrow_right_default))
              ]),
              _: 1
            }, 8, ["class"]))
          ],
          64
        )) : createCommentVNode("v-if", true)
      ], 42, _hoisted_1$1);
    };
  }
});
var ElCascaderNode = /* @__PURE__ */ _export_sfc$1(_sfc_main$7, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/cascader-panel/src/node.vue"]]);
const _sfc_main$6 = defineComponent({
  ...{
    name: "ElCascaderMenu"
  },
  __name: "menu",
  props: {
    nodes: {
      type: Array,
      required: true
    },
    index: {
      type: Number,
      required: true
    }
  },
  setup(__props) {
    const props = __props;
    const instance = getCurrentInstance();
    const ns = useNamespace("cascader-menu");
    const { t: t6 } = useLocale();
    const id = useId();
    let activeNode;
    let hoverTimer;
    const panel = inject(CASCADER_PANEL_INJECTION_KEY);
    const hoverZone = ref();
    const isEmpty2 = computed(() => !props.nodes.length);
    const isLoading = computed(() => !panel.initialLoaded);
    const menuId = computed(() => `${id.value}-${props.index}`);
    const handleExpand = (e12) => {
      activeNode = e12.target;
    };
    const handleMouseMove = (e12) => {
      var _a;
      if (!panel.isHoverMenu || !activeNode || !hoverZone.value)
        return;
      if (activeNode.contains(e12.target)) {
        clearHoverTimer();
        const el = instance.vnode.el;
        const { left } = el.getBoundingClientRect();
        const { offsetWidth, offsetHeight } = el;
        const startX = e12.clientX - left;
        const top = activeNode.offsetTop;
        const bottom = top + activeNode.offsetHeight;
        const scrollTop = ((_a = el.querySelector(`.${ns.e("wrap")}`)) == null ? void 0 : _a.scrollTop) || 0;
        hoverZone.value.innerHTML = `
          <path style="pointer-events: auto;" fill="transparent" d="M${startX} ${top} L${offsetWidth} ${scrollTop} V${top} Z" />
          <path style="pointer-events: auto;" fill="transparent" d="M${startX} ${bottom} L${offsetWidth} ${offsetHeight + scrollTop} V${bottom} Z" />
        `;
      } else if (!hoverTimer) {
        hoverTimer = (void 0).setTimeout(clearHoverZone, panel.config.hoverThreshold);
      }
    };
    const clearHoverTimer = () => {
      if (!hoverTimer)
        return;
      clearTimeout(hoverTimer);
      hoverTimer = void 0;
    };
    const clearHoverZone = () => {
      if (!hoverZone.value)
        return;
      hoverZone.value.innerHTML = "";
      clearHoverTimer();
    };
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(ElScrollbar), {
        key: menuId.value,
        tag: "ul",
        role: "menu",
        class: normalizeClass(unref(ns).b()),
        "wrap-class": unref(ns).e("wrap"),
        "view-class": [unref(ns).e("list"), unref(ns).is("empty", isEmpty2.value)],
        onMousemove: handleMouseMove,
        onMouseleave: clearHoverZone
      }, {
        default: withCtx(() => {
          var _a;
          return [
            (openBlock(true), createElementBlock(
              Fragment,
              null,
              renderList(__props.nodes, (node) => {
                return openBlock(), createBlock(ElCascaderNode, {
                  key: node.uid,
                  node,
                  "menu-id": menuId.value,
                  onExpand: handleExpand
                }, null, 8, ["node", "menu-id"]);
              }),
              128
            )),
            isLoading.value ? (openBlock(), createElementBlock(
              "div",
              {
                key: 0,
                class: normalizeClass(unref(ns).e("empty-text"))
              },
              [
                createVNode(unref(ElIcon), {
                  size: "14",
                  class: normalizeClass(unref(ns).is("loading"))
                }, {
                  default: withCtx(() => [
                    createVNode(unref(loading_default))
                  ]),
                  _: 1
                }, 8, ["class"]),
                createTextVNode(
                  " " + toDisplayString(unref(t6)("el.cascader.loading")),
                  1
                )
              ],
              2
            )) : isEmpty2.value ? (openBlock(), createElementBlock(
              "div",
              {
                key: 1,
                class: normalizeClass(unref(ns).e("empty-text"))
              },
              [
                renderSlot(_ctx.$slots, "empty", {}, () => [
                  createTextVNode(
                    toDisplayString(unref(t6)("el.cascader.noData")),
                    1
                  )
                ])
              ],
              2
            )) : ((_a = unref(panel)) == null ? void 0 : _a.isHoverMenu) ? (openBlock(), createElementBlock(
              Fragment,
              { key: 2 },
              [
                createCommentVNode(" eslint-disable vue/html-self-closing "),
                (openBlock(), createElementBlock(
                  "svg",
                  {
                    ref_key: "hoverZone",
                    ref: hoverZone,
                    class: normalizeClass(unref(ns).e("hover-zone"))
                  },
                  null,
                  2
                ))
              ],
              2112
            )) : createCommentVNode("v-if", true),
            createCommentVNode(" eslint-enable vue/html-self-closing ")
          ];
        }),
        _: 3
      }, 8, ["class", "wrap-class", "view-class"]);
    };
  }
});
var ElCascaderMenu = /* @__PURE__ */ _export_sfc$1(_sfc_main$6, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/cascader-panel/src/menu.vue"]]);
let uid = 0;
const calculatePathNodes = (node) => {
  const nodes = [node];
  let { parent } = node;
  while (parent) {
    nodes.unshift(parent);
    parent = parent.parent;
  }
  return nodes;
};
let Node$1 = class Node {
  constructor(data, config, parent, root = false) {
    this.data = data;
    this.config = config;
    this.parent = parent;
    this.root = root;
    this.uid = uid++;
    this.checked = false;
    this.indeterminate = false;
    this.loading = false;
    const { value: valueKey, label: labelKey, children: childrenKey } = config;
    const childrenData = data[childrenKey];
    const pathNodes = calculatePathNodes(this);
    this.level = root ? 0 : parent ? parent.level + 1 : 1;
    this.value = data[valueKey];
    this.label = data[labelKey];
    this.pathNodes = pathNodes;
    this.pathValues = pathNodes.map((node) => node.value);
    this.pathLabels = pathNodes.map((node) => node.label);
    this.childrenData = childrenData;
    this.children = (childrenData || []).map(
      (child) => new Node(child, config, this)
    );
    this.loaded = !config.lazy || this.isLeaf || !isEmpty(childrenData);
    this.text = "";
  }
  get isDisabled() {
    const { data, parent, config } = this;
    const { disabled, checkStrictly } = config;
    const isDisabled = isFunction(disabled) ? disabled(data, this) : !!data[disabled];
    return isDisabled || !checkStrictly && !!(parent == null ? void 0 : parent.isDisabled);
  }
  get isLeaf() {
    const { data, config, childrenData, loaded } = this;
    const { lazy, leaf } = config;
    const isLeaf2 = isFunction(leaf) ? leaf(data, this) : data[leaf];
    return isUndefined$1(isLeaf2) ? lazy && !loaded ? false : !(isArray(childrenData) && childrenData.length) : !!isLeaf2;
  }
  get valueByOption() {
    return this.config.emitPath ? this.pathValues : this.value;
  }
  appendChild(childData) {
    const { childrenData, children } = this;
    const node = new Node(childData, this.config, this);
    if (isArray(childrenData)) {
      childrenData.push(childData);
    } else {
      this.childrenData = [childData];
    }
    children.push(node);
    return node;
  }
  calcText(allLevels, separator) {
    const text = allLevels ? this.pathLabels.join(separator) : this.label;
    this.text = text;
    return text;
  }
  broadcast(checked) {
    this.children.forEach((child) => {
      var _a;
      if (child) {
        child.broadcast(checked);
        (_a = child.onParentCheck) == null ? void 0 : _a.call(child, checked);
      }
    });
  }
  emit() {
    var _a;
    const { parent } = this;
    if (parent) {
      (_a = parent.onChildCheck) == null ? void 0 : _a.call(parent);
      parent.emit();
    }
  }
  onParentCheck(checked) {
    if (!this.isDisabled) {
      this.setCheckState(checked);
    }
  }
  onChildCheck() {
    const { children } = this;
    const validChildren = children.filter((child) => !child.isDisabled);
    const checked = validChildren.length ? validChildren.every((child) => child.checked) : false;
    this.setCheckState(checked);
  }
  setCheckState(checked) {
    const totalNum = this.children.length;
    const checkedNum = this.children.reduce((c28, p7) => {
      const num = p7.checked ? 1 : p7.indeterminate ? 0.5 : 0;
      return c28 + num;
    }, 0);
    this.checked = this.loaded && this.children.filter((child) => !child.isDisabled).every((child) => child.loaded && child.checked) && checked;
    this.indeterminate = this.loaded && checkedNum !== totalNum && checkedNum > 0;
  }
  doCheck(checked) {
    if (this.checked === checked)
      return;
    const { checkStrictly, multiple } = this.config;
    if (checkStrictly || !multiple) {
      this.checked = checked;
    } else {
      this.broadcast(checked);
      this.setCheckState(checked);
      this.emit();
    }
  }
};
const flatNodes = (nodes, leafOnly) => {
  return nodes.reduce((res, node) => {
    if (node.isLeaf) {
      res.push(node);
    } else {
      !leafOnly && res.push(node);
      res = res.concat(flatNodes(node.children, leafOnly));
    }
    return res;
  }, []);
};
class Store {
  constructor(data, config) {
    this.config = config;
    const nodes = (data || []).map(
      (nodeData) => new Node$1(nodeData, this.config)
    );
    this.nodes = nodes;
    this.allNodes = flatNodes(nodes, false);
    this.leafNodes = flatNodes(nodes, true);
  }
  getNodes() {
    return this.nodes;
  }
  getFlattedNodes(leafOnly) {
    return leafOnly ? this.leafNodes : this.allNodes;
  }
  appendNode(nodeData, parentNode) {
    const node = parentNode ? parentNode.appendChild(nodeData) : new Node$1(nodeData, this.config);
    if (!parentNode)
      this.nodes.push(node);
    this.appendAllNodesAndLeafNodes(node);
  }
  appendNodes(nodeDataList, parentNode) {
    if (nodeDataList.length > 0) {
      nodeDataList.forEach((nodeData) => this.appendNode(nodeData, parentNode));
    } else {
      parentNode && parentNode.isLeaf && this.leafNodes.push(parentNode);
    }
  }
  appendAllNodesAndLeafNodes(node) {
    this.allNodes.push(node);
    node.isLeaf && this.leafNodes.push(node);
    if (node.children) {
      node.children.forEach((subNode) => {
        this.appendAllNodesAndLeafNodes(subNode);
      });
    }
  }
  getNodeByValue(value, leafOnly = false) {
    if (isPropAbsent(value))
      return null;
    const node = this.getFlattedNodes(leafOnly).find(
      (node2) => isEqual(node2.value, value) || isEqual(node2.pathValues, value)
    );
    return node || null;
  }
  getSameNode(node) {
    if (!node)
      return null;
    const node_ = this.getFlattedNodes(false).find(
      ({ value, level }) => isEqual(node.value, value) && node.level === level
    );
    return node_ || null;
  }
}
const CommonProps = buildProps({
  modelValue: {
    type: definePropType([Number, String, Array, Object])
  },
  options: {
    type: definePropType(Array),
    default: () => []
  },
  props: {
    type: definePropType(Object),
    default: () => ({})
  }
});
const DefaultProps = {
  expandTrigger: "click",
  multiple: false,
  checkStrictly: false,
  emitPath: true,
  lazy: false,
  lazyLoad: NOOP,
  value: "value",
  label: "label",
  children: "children",
  leaf: "leaf",
  disabled: "disabled",
  hoverThreshold: 500,
  checkOnClickNode: false,
  checkOnClickLeaf: true,
  showPrefix: true
};
const cascaderPanelProps = buildProps({
  ...CommonProps,
  border: {
    type: Boolean,
    default: true
  },
  renderLabel: {
    type: Function
  }
});
const emitChangeFn$2 = (value) => true;
const cascaderPanelEmits = {
  [UPDATE_MODEL_EVENT]: emitChangeFn$2,
  [CHANGE_EVENT]: emitChangeFn$2,
  close: () => true,
  "expand-change": (value) => value
};
const useCascaderConfig = (props) => {
  return computed(() => ({
    ...DefaultProps,
    ...props.props
  }));
};
const getMenuIndex = (el) => {
  if (!el)
    return 0;
  const pieces = el.id.split("-");
  return Number(pieces[pieces.length - 2]);
};
const checkNode = (el) => {
  if (!el)
    return;
  const input = el.querySelector("input");
  if (input) {
    input.click();
  } else if (isLeaf(el)) {
    el.click();
  }
};
const sortByOriginalOrder = (oldNodes, newNodes) => {
  const newNodesCopy = newNodes.slice(0);
  const newIds = newNodesCopy.map((node) => node.uid);
  const res = oldNodes.reduce((acc, item) => {
    const index = newIds.indexOf(item.uid);
    if (index > -1) {
      acc.push(item);
      newNodesCopy.splice(index, 1);
      newIds.splice(index, 1);
    }
    return acc;
  }, []);
  res.push(...newNodesCopy);
  return res;
};
const _sfc_main$5 = defineComponent({
  ...{
    name: "ElCascaderPanel"
  },
  __name: "index",
  props: cascaderPanelProps,
  emits: cascaderPanelEmits,
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    let manualChecked = false;
    const ns = useNamespace("cascader");
    const config = useCascaderConfig(props);
    const slots = useSlots();
    let store;
    const initialLoaded = ref(true);
    const initialLoadedOnce = ref(false);
    const menuList = ref([]);
    const checkedValue = ref();
    const menus = ref([]);
    const expandingNode = ref();
    const checkedNodes = ref([]);
    const isHoverMenu = computed(() => config.value.expandTrigger === "hover");
    const renderLabelFn = computed(() => props.renderLabel || slots.default);
    const initStore = () => {
      const { options } = props;
      const cfg = config.value;
      manualChecked = false;
      store = new Store(options, cfg);
      menus.value = [store.getNodes()];
      if (cfg.lazy && isEmpty(props.options)) {
        initialLoaded.value = false;
        lazyLoad(void 0, (list) => {
          if (list) {
            store = new Store(list, cfg);
            menus.value = [store.getNodes()];
          }
          initialLoaded.value = true;
          syncCheckedValue(false, true);
        });
      } else {
        syncCheckedValue(false, true);
      }
    };
    const lazyLoad = (node, cb2) => {
      const cfg = config.value;
      node = node || new Node$1({}, cfg, void 0, true);
      node.loading = true;
      const resolve = (dataList) => {
        const _node = node;
        const parent = _node.root ? null : _node;
        _node.loading = false;
        _node.loaded = true;
        _node.childrenData = _node.childrenData || [];
        dataList && (store == null ? void 0 : store.appendNodes(dataList, parent));
        dataList && (cb2 == null ? void 0 : cb2(dataList));
        if (node.level === 0) {
          initialLoadedOnce.value = true;
        }
      };
      const reject = () => {
        node.loading = false;
        node.loaded = false;
        if (node.level === 0) {
          initialLoaded.value = true;
        }
      };
      cfg.lazyLoad(node, resolve, reject);
    };
    const expandNode = (node, silent) => {
      var _a;
      const { level } = node;
      const newMenus = menus.value.slice(0, level);
      let newExpandingNode;
      if (node.isLeaf) {
        newExpandingNode = node.pathNodes[level - 2];
      } else {
        newExpandingNode = node;
        newMenus.push(node.children);
      }
      if (((_a = expandingNode.value) == null ? void 0 : _a.uid) !== (newExpandingNode == null ? void 0 : newExpandingNode.uid)) {
        expandingNode.value = node;
        menus.value = newMenus;
        !silent && emit("expand-change", (node == null ? void 0 : node.pathValues) || []);
      }
    };
    const handleCheckChange = (node, checked, emitClose = true) => {
      const { checkStrictly, multiple } = config.value;
      const oldNode = checkedNodes.value[0];
      manualChecked = true;
      !multiple && (oldNode == null ? void 0 : oldNode.doCheck(false));
      node.doCheck(checked);
      calculateCheckedValue();
      emitClose && !multiple && !checkStrictly && emit("close");
      !emitClose && !multiple && expandParentNode(node);
    };
    const expandParentNode = (node) => {
      if (!node)
        return;
      node = node.parent;
      expandParentNode(node);
      node && expandNode(node);
    };
    const getFlattedNodes = (leafOnly) => store == null ? void 0 : store.getFlattedNodes(leafOnly);
    const getCheckedNodes = (leafOnly) => {
      var _a;
      return (_a = getFlattedNodes(leafOnly)) == null ? void 0 : _a.filter(({ checked }) => checked !== false);
    };
    const clearCheckedNodes = () => {
      checkedNodes.value.forEach((node) => node.doCheck(false));
      calculateCheckedValue();
      menus.value = menus.value.slice(0, 1);
      expandingNode.value = void 0;
      emit("expand-change", []);
    };
    const calculateCheckedValue = () => {
      var _a;
      const { checkStrictly, multiple } = config.value;
      const oldNodes = checkedNodes.value;
      const newNodes = getCheckedNodes(!checkStrictly);
      const nodes = sortByOriginalOrder(oldNodes, newNodes);
      const values = nodes.map((node) => node.valueByOption);
      checkedNodes.value = nodes;
      checkedValue.value = multiple ? values : (_a = values[0]) != null ? _a : null;
    };
    const syncCheckedValue = (loaded = false, forced = false) => {
      const { modelValue } = props;
      const { lazy, multiple, checkStrictly } = config.value;
      const leafOnly = !checkStrictly;
      if (!initialLoaded.value || manualChecked || !forced && isEqual(modelValue, checkedValue.value))
        return;
      if (lazy && !loaded) {
        const values = unique(
          flattenDeep(castArray$1(modelValue))
        );
        const nodes = values.map((val) => store == null ? void 0 : store.getNodeByValue(val)).filter((node) => !!node && !node.loaded && !node.loading);
        if (nodes.length) {
          nodes.forEach((node) => {
            lazyLoad(node, () => syncCheckedValue(false, forced));
          });
        } else {
          syncCheckedValue(true, forced);
        }
      } else {
        const values = multiple ? castArray$1(modelValue) : [modelValue];
        const nodes = unique(
          values.map(
            (val) => store == null ? void 0 : store.getNodeByValue(val, leafOnly)
          )
        );
        syncMenuState(nodes, forced);
        checkedValue.value = cloneDeep(modelValue != null ? modelValue : void 0);
      }
    };
    const syncMenuState = (newCheckedNodes, reserveExpandingState = true) => {
      const { checkStrictly } = config.value;
      const oldNodes = checkedNodes.value;
      const newNodes = newCheckedNodes.filter(
        (node) => !!node && (checkStrictly || node.isLeaf)
      );
      const oldExpandingNode = store == null ? void 0 : store.getSameNode(expandingNode.value);
      const newExpandingNode = reserveExpandingState && oldExpandingNode || newNodes[0];
      if (newExpandingNode) {
        newExpandingNode.pathNodes.forEach((node) => expandNode(node, true));
      } else {
        expandingNode.value = void 0;
      }
      oldNodes.forEach((node) => node.doCheck(false));
      reactive(newNodes).forEach((node) => node.doCheck(true));
      checkedNodes.value = newNodes;
      nextTick(scrollToExpandingNode);
    };
    const scrollToExpandingNode = () => {
      if (!isClient)
        return;
      menuList.value.forEach((menu) => {
        const menuElement = menu == null ? void 0 : menu.$el;
        if (menuElement) {
          const container = menuElement.querySelector(
            `.${ns.namespace.value}-scrollbar__wrap`
          );
          let activeNode = menuElement.querySelector(
            `.${ns.b("node")}.in-active-path`
          );
          if (!activeNode) {
            const activeElements = menuElement.querySelectorAll(
              `.${ns.b("node")}.${ns.is("active")}`
            );
            activeNode = activeElements[activeElements.length - 1];
          }
          scrollIntoView(container, activeNode);
        }
      });
    };
    const handleKeyDown = (e12) => {
      const target = e12.target;
      const code = getEventCode(e12);
      switch (code) {
        case EVENT_CODE.up:
        case EVENT_CODE.down: {
          e12.preventDefault();
          const distance = code === EVENT_CODE.up ? -1 : 1;
          focusNode(
            getSibling(
              target,
              distance,
              `.${ns.b("node")}[tabindex="-1"]`
            )
          );
          break;
        }
        case EVENT_CODE.left: {
          e12.preventDefault();
          const preMenu = menuList.value[getMenuIndex(target) - 1];
          const expandedNode = preMenu == null ? void 0 : preMenu.$el.querySelector(
            `.${ns.b("node")}[aria-expanded="true"]`
          );
          focusNode(expandedNode);
          break;
        }
        case EVENT_CODE.right: {
          e12.preventDefault();
          const nextMenu = menuList.value[getMenuIndex(target) + 1];
          const firstNode = nextMenu == null ? void 0 : nextMenu.$el.querySelector(
            `.${ns.b("node")}[tabindex="-1"]`
          );
          focusNode(firstNode);
          break;
        }
        case EVENT_CODE.enter:
        case EVENT_CODE.numpadEnter:
          checkNode(target);
          break;
      }
    };
    provide(
      CASCADER_PANEL_INJECTION_KEY,
      reactive({
        config,
        expandingNode,
        checkedNodes,
        isHoverMenu,
        initialLoaded,
        renderLabelFn,
        lazyLoad,
        expandNode,
        handleCheckChange
      })
    );
    watch(
      config,
      (newVal, oldVal) => {
        if (isEqual(newVal, oldVal))
          return;
        initStore();
      },
      {
        immediate: true
      }
    );
    watch(() => props.options, initStore, {
      deep: true
    });
    watch(
      () => props.modelValue,
      () => {
        manualChecked = false;
        syncCheckedValue();
      },
      {
        deep: true
      }
    );
    watch(
      () => checkedValue.value,
      (val) => {
        if (!isEqual(val, props.modelValue)) {
          emit(UPDATE_MODEL_EVENT, val);
          emit(CHANGE_EVENT, val);
        }
      }
    );
    const loadLazyRootNodes = () => {
      if (initialLoadedOnce.value)
        return;
      initStore();
    };
    __expose({
      menuList,
      menus,
      checkedNodes,
      handleKeyDown,
      handleCheckChange,
      getFlattedNodes,
      getCheckedNodes,
      clearCheckedNodes,
      calculateCheckedValue,
      scrollToExpandingNode,
      loadLazyRootNodes
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(
        "div",
        {
          class: normalizeClass([unref(ns).b("panel"), unref(ns).is("bordered", _ctx.border)]),
          onKeydown: handleKeyDown
        },
        [
          (openBlock(true), createElementBlock(
            Fragment,
            null,
            renderList(menus.value, (menu, index) => {
              return openBlock(), createBlock(ElCascaderMenu, {
                key: index,
                ref_for: true,
                ref: (item) => menuList.value[index] = item,
                index,
                nodes: [...menu]
              }, {
                empty: withCtx(() => [
                  renderSlot(_ctx.$slots, "empty")
                ]),
                _: 3
              }, 8, ["index", "nodes"]);
            }),
            128
          ))
        ],
        34
      );
    };
  }
});
var CascaderPanel = /* @__PURE__ */ _export_sfc$1(_sfc_main$5, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/cascader-panel/src/index.vue"]]);
withInstall(CascaderPanel);
buildProps({
  ...CommonProps,
  size: useSizeProp,
  placeholder: String,
  disabled: {
    type: Boolean,
    default: void 0
  },
  clearable: Boolean,
  clearIcon: {
    type: iconPropType,
    default: circle_close_default
  },
  filterable: Boolean,
  filterMethod: {
    type: definePropType(
      Function
    ),
    default: (node, keyword) => node.text.includes(keyword)
  },
  separator: {
    type: String,
    default: " / "
  },
  showAllLevels: {
    type: Boolean,
    default: true
  },
  collapseTags: Boolean,
  maxCollapseTags: {
    type: Number,
    default: 1
  },
  collapseTagsTooltip: Boolean,
  maxCollapseTagsTooltipHeight: {
    type: [String, Number]
  },
  debounce: {
    type: Number,
    default: 300
  },
  beforeFilter: {
    type: definePropType(Function),
    default: () => true
  },
  placement: {
    type: definePropType(String),
    values: placements,
    default: "bottom-start"
  },
  fallbackPlacements: {
    type: definePropType(Array),
    default: ["bottom-start", "bottom", "top-start", "top", "right", "left"]
  },
  popperClass: useTooltipContentProps.popperClass,
  popperStyle: useTooltipContentProps.popperStyle,
  teleported: useTooltipContentProps.teleported,
  effect: {
    type: definePropType(String),
    default: "light"
  },
  tagType: { ...tagProps.type, default: "info" },
  tagEffect: { ...tagProps.effect, default: "light" },
  validateEvent: {
    type: Boolean,
    default: true
  },
  persistent: {
    type: Boolean,
    default: true
  },
  showCheckedStrategy: {
    type: String,
    values: ["parent", "child"],
    default: "child"
  },
  checkOnClickNode: Boolean,
  showPrefix: {
    type: Boolean,
    default: true
  },
  ...useEmptyValuesProps
});
buildProps({
  checked: Boolean,
  disabled: Boolean,
  type: {
    type: String,
    values: ["primary", "success", "info", "warning", "danger"],
    default: "primary"
  }
});
buildProps({
  accordion: Boolean,
  modelValue: {
    type: definePropType([Array, String, Number]),
    default: () => mutable([])
  },
  expandIconPosition: {
    type: definePropType([String]),
    default: "right"
  },
  beforeCollapse: {
    type: definePropType(
      Function
    )
  }
});
buildProps({
  title: {
    type: String,
    default: ""
  },
  name: {
    type: definePropType([String, Number]),
    default: void 0
  },
  icon: {
    type: iconPropType,
    default: arrow_right_default
  },
  disabled: Boolean
});
buildProps({
  modelValue: {
    type: definePropType(Array)
  },
  max: Number,
  tagType: { ...tagProps.type, default: "info" },
  tagEffect: tagProps.effect,
  trigger: {
    type: definePropType(String),
    default: EVENT_CODE.enter
  },
  draggable: Boolean,
  delimiter: {
    type: [String, RegExp],
    default: ""
  },
  size: useSizeProp,
  clearable: Boolean,
  clearIcon: {
    type: iconPropType,
    default: circle_close_default
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  validateEvent: {
    type: Boolean,
    default: true
  },
  readonly: Boolean,
  autofocus: Boolean,
  id: {
    type: String,
    default: void 0
  },
  tabindex: {
    type: [String, Number],
    default: 0
  },
  maxlength: {
    type: [String, Number]
  },
  minlength: {
    type: [String, Number]
  },
  placeholder: String,
  autocomplete: {
    type: definePropType(String),
    default: "off"
  },
  saveOnBlur: {
    type: Boolean,
    default: true
  },
  collapseTags: Boolean,
  collapseTagsTooltip: Boolean,
  maxCollapseTags: {
    type: Number,
    default: 1
  },
  ariaLabel: String
});
buildProps({
  type: {
    type: String,
    values: ["primary", "success", "warning", "info", "danger", "default"],
    default: void 0
  },
  underline: {
    type: [Boolean, String],
    values: [true, false, "always", "never", "hover"],
    default: void 0
  },
  disabled: Boolean,
  href: { type: String, default: "" },
  target: {
    type: String,
    default: "_self"
  },
  icon: {
    type: iconPropType
  }
});
buildProps({
  icon: {
    type: iconPropType,
    default: () => back_default
  },
  title: String,
  content: {
    type: String,
    default: ""
  }
});
const popoverProps = buildProps({
  trigger: useTooltipTriggerProps.trigger,
  triggerKeys: useTooltipTriggerProps.triggerKeys,
  placement: dropdownProps.placement,
  disabled: useTooltipTriggerProps.disabled,
  visible: useTooltipContentProps.visible,
  transition: useTooltipContentProps.transition,
  popperOptions: dropdownProps.popperOptions,
  tabindex: dropdownProps.tabindex,
  content: useTooltipContentProps.content,
  popperStyle: useTooltipContentProps.popperStyle,
  popperClass: useTooltipContentProps.popperClass,
  enterable: {
    ...useTooltipContentProps.enterable,
    default: true
  },
  effect: {
    ...useTooltipContentProps.effect,
    default: "light"
  },
  teleported: useTooltipContentProps.teleported,
  appendTo: useTooltipContentProps.appendTo,
  title: String,
  width: {
    type: [String, Number],
    default: 150
  },
  offset: {
    type: Number,
    default: void 0
  },
  showAfter: {
    type: Number,
    default: 0
  },
  hideAfter: {
    type: Number,
    default: 200
  },
  autoClose: {
    type: Number,
    default: 0
  },
  showArrow: {
    type: Boolean,
    default: true
  },
  persistent: {
    type: Boolean,
    default: true
  },
  "onUpdate:visible": {
    type: Function
  }
});
const popoverEmits = {
  "update:visible": (value) => isBoolean$1(value),
  "before-enter": () => true,
  "before-leave": () => true,
  "after-enter": () => true,
  "after-leave": () => true
};
const updateEventKeyRaw = `onUpdate:visible`;
const _sfc_main$4 = defineComponent({
  ...{
    name: "ElPopover"
  },
  __name: "popover",
  props: popoverProps,
  emits: popoverEmits,
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const onUpdateVisible = computed(() => {
      return props[updateEventKeyRaw];
    });
    const ns = useNamespace("popover");
    const tooltipRef = ref();
    const popperRef = computed(() => {
      var _a;
      return (_a = unref(tooltipRef)) == null ? void 0 : _a.popperRef;
    });
    const style = computed(() => {
      return [
        {
          width: addUnit(props.width)
        },
        props.popperStyle
      ];
    });
    const kls = computed(() => {
      return [ns.b(), props.popperClass, { [ns.m("plain")]: !!props.content }];
    });
    const gpuAcceleration = computed(() => {
      return props.transition === `${ns.namespace.value}-fade-in-linear`;
    });
    const hide = () => {
      var _a;
      (_a = tooltipRef.value) == null ? void 0 : _a.hide();
    };
    const beforeEnter = () => {
      emit("before-enter");
    };
    const beforeLeave = () => {
      emit("before-leave");
    };
    const afterEnter = () => {
      emit("after-enter");
    };
    const afterLeave = () => {
      emit("update:visible", false);
      emit("after-leave");
    };
    __expose({
      popperRef,
      hide
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(ElTooltip), mergeProps({
        ref_key: "tooltipRef",
        ref: tooltipRef
      }, _ctx.$attrs, {
        trigger: _ctx.trigger,
        "trigger-keys": _ctx.triggerKeys,
        placement: _ctx.placement,
        disabled: _ctx.disabled,
        visible: _ctx.visible,
        transition: _ctx.transition,
        "popper-options": _ctx.popperOptions,
        tabindex: _ctx.tabindex,
        content: _ctx.content,
        offset: _ctx.offset,
        "show-after": _ctx.showAfter,
        "hide-after": _ctx.hideAfter,
        "auto-close": _ctx.autoClose,
        "show-arrow": _ctx.showArrow,
        "aria-label": _ctx.title,
        effect: _ctx.effect,
        enterable: _ctx.enterable,
        "popper-class": kls.value,
        "popper-style": style.value,
        teleported: _ctx.teleported,
        "append-to": _ctx.appendTo,
        persistent: _ctx.persistent,
        "gpu-acceleration": gpuAcceleration.value,
        "onUpdate:visible": onUpdateVisible.value,
        onBeforeShow: beforeEnter,
        onBeforeHide: beforeLeave,
        onShow: afterEnter,
        onHide: afterLeave
      }), {
        content: withCtx(() => [
          _ctx.title ? (openBlock(), createElementBlock(
            "div",
            {
              key: 0,
              class: normalizeClass(unref(ns).e("title")),
              role: "title"
            },
            toDisplayString(_ctx.title),
            3
          )) : createCommentVNode("v-if", true),
          renderSlot(_ctx.$slots, "default", {}, () => [
            createTextVNode(
              toDisplayString(_ctx.content),
              1
            )
          ])
        ]),
        default: withCtx(() => [
          _ctx.$slots.reference ? renderSlot(_ctx.$slots, "reference", { key: 0 }) : createCommentVNode("v-if", true)
        ]),
        _: 3
      }, 16, ["trigger", "trigger-keys", "placement", "disabled", "visible", "transition", "popper-options", "tabindex", "content", "offset", "show-after", "hide-after", "auto-close", "show-arrow", "aria-label", "effect", "enterable", "popper-class", "popper-style", "teleported", "append-to", "persistent", "gpu-acceleration", "onUpdate:visible"]);
    };
  }
});
var Popover = /* @__PURE__ */ _export_sfc$1(_sfc_main$4, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popover/src/popover.vue"]]);
const attachEvents = (el, binding) => {
  const popperComponent = binding.arg || binding.value;
  const popover = popperComponent == null ? void 0 : popperComponent.popperRef;
  if (popover) {
    popover.triggerRef = el;
  }
};
var PopoverDirective = {
  mounted(el, binding) {
    attachEvents(el, binding);
  },
  updated(el, binding) {
    attachEvents(el, binding);
  }
};
const VPopover = "popover";
const ElPopoverDirective = withInstallDirective(PopoverDirective, VPopover);
withInstall(Popover, {
  directive: ElPopoverDirective
});
buildProps({
  modelValue: {
    type: Number,
    default: 0
  },
  id: {
    type: String,
    default: void 0
  },
  lowThreshold: {
    type: Number,
    default: 2
  },
  highThreshold: {
    type: Number,
    default: 4
  },
  max: {
    type: Number,
    default: 5
  },
  colors: {
    type: definePropType([Array, Object]),
    default: () => mutable(["", "", ""])
  },
  voidColor: {
    type: String,
    default: ""
  },
  disabledVoidColor: {
    type: String,
    default: ""
  },
  icons: {
    type: definePropType([Array, Object]),
    default: () => [star_filled_default, star_filled_default, star_filled_default]
  },
  voidIcon: {
    type: iconPropType,
    default: () => star_default
  },
  disabledVoidIcon: {
    type: iconPropType,
    default: () => star_filled_default
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  allowHalf: Boolean,
  showText: Boolean,
  showScore: Boolean,
  textColor: {
    type: String,
    default: ""
  },
  texts: {
    type: definePropType(Array),
    default: () => mutable([
      "Extremely bad",
      "Disappointed",
      "Fair",
      "Satisfied",
      "Surprise"
    ])
  },
  scoreTemplate: {
    type: String,
    default: "{value}"
  },
  size: useSizeProp,
  clearable: Boolean,
  ...useAriaProps(["ariaLabel"])
});
buildProps({
  title: {
    type: String,
    default: ""
  },
  subTitle: {
    type: String,
    default: ""
  },
  icon: {
    type: String,
    values: ["primary", "success", "warning", "info", "error"],
    default: "info"
  }
});
const useCache = () => {
  const vm = getCurrentInstance();
  const props = vm.proxy.$props;
  return computed(() => {
    const _getItemStyleCache = (_, __, ___) => ({});
    return props.perfMode ? memoize(_getItemStyleCache) : memoOne(_getItemStyleCache);
  });
};
const itemSize = buildProp({
  type: definePropType([Number, Function]),
  required: true
});
const estimatedItemSize = buildProp({
  type: Number
});
const cache = buildProp({
  type: Number,
  default: 2
});
const direction = buildProp({
  type: String,
  values: ["ltr", "rtl"],
  default: "ltr"
});
const initScrollOffset = buildProp({
  type: Number,
  default: 0
});
const total = buildProp({
  type: Number,
  required: true
});
const layout = buildProp({
  type: String,
  values: ["horizontal", "vertical"],
  default: VERTICAL
});
const virtualizedProps = buildProps({
  className: {
    type: String,
    default: ""
  },
  containerElement: {
    type: definePropType([String, Object]),
    default: "div"
  },
  data: {
    type: definePropType(Array),
    default: () => mutable([])
  },
  direction,
  height: {
    type: [String, Number],
    required: true
  },
  innerElement: {
    type: [String, Object],
    default: "div"
  },
  innerProps: {
    type: definePropType(Object),
    default: () => ({})
  },
  style: {
    type: definePropType([Object, String, Array])
  },
  useIsScrolling: Boolean,
  width: {
    type: [Number, String],
    required: false
  },
  perfMode: {
    type: Boolean,
    default: true
  },
  scrollbarAlwaysOn: Boolean
});
const virtualizedListProps = buildProps({
  cache,
  estimatedItemSize,
  layout,
  initScrollOffset,
  total,
  itemSize,
  ...virtualizedProps
});
const scrollbarSize = {
  type: Number,
  default: 6
};
const startGap = { type: Number, default: 0 };
const endGap = { type: Number, default: 2 };
const virtualizedGridProps = buildProps({
  columnCache: cache,
  columnWidth: itemSize,
  estimatedColumnWidth: estimatedItemSize,
  estimatedRowHeight: estimatedItemSize,
  initScrollLeft: initScrollOffset,
  initScrollTop: initScrollOffset,
  itemKey: {
    type: definePropType(Function),
    default: ({
      columnIndex,
      rowIndex
    }) => `${rowIndex}:${columnIndex}`
  },
  rowCache: cache,
  rowHeight: itemSize,
  totalColumn: total,
  totalRow: total,
  hScrollbarSize: scrollbarSize,
  vScrollbarSize: scrollbarSize,
  scrollbarStartGap: startGap,
  scrollbarEndGap: endGap,
  role: String,
  ...virtualizedProps
});
const virtualizedScrollbarProps = buildProps({
  alwaysOn: Boolean,
  class: String,
  layout,
  total,
  ratio: {
    type: Number,
    required: true
  },
  clientSize: {
    type: Number,
    required: true
  },
  scrollFrom: {
    type: Number,
    required: true
  },
  scrollbarSize,
  startGap,
  endGap,
  visible: Boolean
});
const getScrollDir = (prev, cur) => prev < cur ? FORWARD : BACKWARD;
const isHorizontal = (dir) => dir === LTR || dir === RTL || dir === HORIZONTAL;
const isRTL = (dir) => dir === RTL;
let cachedRTLResult = null;
function getRTLOffsetType(recalculate = false) {
  if (cachedRTLResult === null || recalculate) {
    const outerDiv = (void 0).createElement("div");
    const outerStyle = outerDiv.style;
    outerStyle.width = "50px";
    outerStyle.height = "50px";
    outerStyle.overflow = "scroll";
    outerStyle.direction = "rtl";
    const innerDiv = (void 0).createElement("div");
    const innerStyle = innerDiv.style;
    innerStyle.width = "100px";
    innerStyle.height = "100px";
    outerDiv.appendChild(innerDiv);
    (void 0).body.appendChild(outerDiv);
    if (outerDiv.scrollLeft > 0) {
      cachedRTLResult = RTL_OFFSET_POS_DESC;
    } else {
      outerDiv.scrollLeft = 1;
      if (outerDiv.scrollLeft === 0) {
        cachedRTLResult = RTL_OFFSET_NAG;
      } else {
        cachedRTLResult = RTL_OFFSET_POS_ASC;
      }
    }
    (void 0).body.removeChild(outerDiv);
    return cachedRTLResult;
  }
  return cachedRTLResult;
}
function renderThumbStyle({ move, size, bar }, layout2) {
  const style = {};
  const translate = `translate${bar.axis}(${move}px)`;
  style[bar.size] = size;
  style.transform = translate;
  if (layout2 === "horizontal") {
    style.height = "100%";
  } else {
    style.width = "100%";
  }
  return style;
}
const ScrollBar = defineComponent({
  name: "ElVirtualScrollBar",
  props: virtualizedScrollbarProps,
  emits: ["scroll", "start-move", "stop-move"],
  setup(props, { emit }) {
    const GAP = computed(() => props.startGap + props.endGap);
    const nsVirtualScrollbar = useNamespace("virtual-scrollbar");
    const nsScrollbar = useNamespace("scrollbar");
    const trackRef = ref();
    const thumbRef = ref();
    let frameHandle = null;
    let onselectstartStore = null;
    const state = reactive({
      isDragging: false,
      traveled: 0
    });
    const bar = computed(() => BAR_MAP[props.layout]);
    const trackSize = computed(() => props.clientSize - unref(GAP));
    const trackStyle = computed(() => ({
      position: "absolute",
      width: `${HORIZONTAL === props.layout ? trackSize.value : props.scrollbarSize}px`,
      height: `${HORIZONTAL === props.layout ? props.scrollbarSize : trackSize.value}px`,
      [ScrollbarDirKey[props.layout]]: "2px",
      right: "2px",
      bottom: "2px",
      borderRadius: "4px"
    }));
    const thumbSize = computed(() => {
      const ratio = props.ratio;
      if (ratio >= 100) {
        return Number.POSITIVE_INFINITY;
      }
      if (ratio >= 50) {
        return ratio * trackSize.value / 100;
      }
      const SCROLLBAR_MAX_SIZE = trackSize.value / 3;
      return Math.floor(
        Math.min(
          Math.max(ratio * trackSize.value / 100, SCROLLBAR_MIN_SIZE),
          SCROLLBAR_MAX_SIZE
        )
      );
    });
    const thumbStyle = computed(() => {
      if (!Number.isFinite(thumbSize.value)) {
        return {
          display: "none"
        };
      }
      const thumb = `${thumbSize.value}px`;
      const style = renderThumbStyle(
        {
          bar: bar.value,
          size: thumb,
          move: state.traveled
        },
        props.layout
      );
      return style;
    });
    const totalSteps = computed(
      () => Math.ceil(props.clientSize - thumbSize.value - unref(GAP))
    );
    const attachEvents2 = () => {
      (void 0).addEventListener("mousemove", onMouseMove);
      (void 0).addEventListener("mouseup", onMouseUp);
      const thumbEl = unref(thumbRef);
      if (!thumbEl)
        return;
      onselectstartStore = (void 0).onselectstart;
      (void 0).onselectstart = () => false;
      thumbEl.addEventListener("touchmove", onMouseMove, { passive: true });
      thumbEl.addEventListener("touchend", onMouseUp);
    };
    const detachEvents = () => {
      (void 0).removeEventListener("mousemove", onMouseMove);
      (void 0).removeEventListener("mouseup", onMouseUp);
      (void 0).onselectstart = onselectstartStore;
      onselectstartStore = null;
      const thumbEl = unref(thumbRef);
      if (!thumbEl)
        return;
      thumbEl.removeEventListener("touchmove", onMouseMove);
      thumbEl.removeEventListener("touchend", onMouseUp);
    };
    const onThumbMouseDown = (e12) => {
      e12.stopImmediatePropagation();
      if (e12.ctrlKey || [1, 2].includes(e12.button)) {
        return;
      }
      state.isDragging = true;
      state[bar.value.axis] = e12.currentTarget[bar.value.offset] - (e12[bar.value.client] - e12.currentTarget.getBoundingClientRect()[bar.value.direction]);
      emit("start-move");
      attachEvents2();
    };
    const onMouseUp = () => {
      state.isDragging = false;
      state[bar.value.axis] = 0;
      emit("stop-move");
      detachEvents();
    };
    const onMouseMove = (e12) => {
      const { isDragging } = state;
      if (!isDragging)
        return;
      if (!thumbRef.value || !trackRef.value)
        return;
      const prevPage = state[bar.value.axis];
      if (!prevPage)
        return;
      cAF(frameHandle);
      const offset = (trackRef.value.getBoundingClientRect()[bar.value.direction] - e12[bar.value.client]) * -1;
      const thumbClickPosition = thumbRef.value[bar.value.offset] - prevPage;
      const distance = offset - thumbClickPosition;
      frameHandle = rAF(() => {
        state.traveled = Math.max(0, Math.min(distance, totalSteps.value));
        emit("scroll", distance, totalSteps.value);
      });
    };
    const clickTrackHandler = (e12) => {
      const offset = Math.abs(
        e12.target.getBoundingClientRect()[bar.value.direction] - e12[bar.value.client]
      );
      const thumbHalf = thumbRef.value[bar.value.offset] / 2;
      const distance = offset - thumbHalf;
      state.traveled = Math.max(0, Math.min(distance, totalSteps.value));
      emit("scroll", distance, totalSteps.value);
    };
    watch(
      () => props.scrollFrom,
      (v6) => {
        if (state.isDragging)
          return;
        state.traveled = Math.ceil(v6 * totalSteps.value);
      }
    );
    return () => {
      return h(
        "div",
        {
          role: "presentation",
          ref: trackRef,
          class: [
            nsVirtualScrollbar.b(),
            props.class,
            (props.alwaysOn || state.isDragging) && "always-on"
          ],
          style: trackStyle.value,
          onMousedown: withModifiers(clickTrackHandler, [
            "stop",
            "prevent"
          ]),
          onTouchstartPrevent: onThumbMouseDown
        },
        h(
          "div",
          {
            ref: thumbRef,
            class: nsScrollbar.e("thumb"),
            style: thumbStyle.value,
            onMousedown: onThumbMouseDown
          },
          []
        )
      );
    };
  }
});
const createList = ({
  name,
  getOffset: getOffset2,
  getItemSize,
  getItemOffset,
  getEstimatedTotalSize: getEstimatedTotalSize2,
  getStartIndexForOffset,
  getStopIndexForStartIndex,
  initCache,
  clearCache,
  validateProps
}) => {
  return defineComponent({
    name: name != null ? name : "ElVirtualList",
    props: virtualizedListProps,
    emits: [ITEM_RENDER_EVT, SCROLL_EVT],
    setup(props, { emit, expose }) {
      validateProps(props);
      const instance = getCurrentInstance();
      const ns = useNamespace("vl");
      const dynamicSizeCache = ref(initCache(props, instance));
      const getItemStyleCache = useCache();
      const windowRef = ref();
      const innerRef = ref();
      const scrollbarRef = ref();
      const states = ref({
        isScrolling: false,
        scrollDir: "forward",
        scrollOffset: isNumber$1(props.initScrollOffset) ? props.initScrollOffset : 0,
        updateRequested: false,
        isScrollbarDragging: false,
        scrollbarAlwaysOn: props.scrollbarAlwaysOn
      });
      const itemsToRender = computed(() => {
        const { total: total2, cache: cache2 } = props;
        const { isScrolling, scrollDir, scrollOffset } = unref(states);
        if (total2 === 0) {
          return [0, 0, 0, 0];
        }
        const startIndex = getStartIndexForOffset(
          props,
          scrollOffset,
          unref(dynamicSizeCache)
        );
        const stopIndex = getStopIndexForStartIndex(
          props,
          startIndex,
          scrollOffset,
          unref(dynamicSizeCache)
        );
        const cacheBackward = !isScrolling || scrollDir === BACKWARD ? Math.max(1, cache2) : 1;
        const cacheForward = !isScrolling || scrollDir === FORWARD ? Math.max(1, cache2) : 1;
        return [
          Math.max(0, startIndex - cacheBackward),
          Math.max(0, Math.min(total2 - 1, stopIndex + cacheForward)),
          startIndex,
          stopIndex
        ];
      });
      const estimatedTotalSize = computed(
        () => getEstimatedTotalSize2(props, unref(dynamicSizeCache))
      );
      const _isHorizontal = computed(() => isHorizontal(props.layout));
      const windowStyle = computed(() => [
        {
          position: "relative",
          [`overflow-${_isHorizontal.value ? "x" : "y"}`]: "scroll",
          WebkitOverflowScrolling: "touch",
          willChange: "transform"
        },
        {
          direction: props.direction,
          height: isNumber$1(props.height) ? `${props.height}px` : props.height,
          width: isNumber$1(props.width) ? `${props.width}px` : props.width
        },
        props.style
      ]);
      const innerStyle = computed(() => {
        const size = unref(estimatedTotalSize);
        const horizontal = unref(_isHorizontal);
        return {
          height: horizontal ? "100%" : `${size}px`,
          pointerEvents: unref(states).isScrolling ? "none" : void 0,
          width: horizontal ? `${size}px` : "100%",
          margin: 0,
          boxSizing: "border-box"
        };
      });
      const clientSize = computed(
        () => _isHorizontal.value ? props.width : props.height
      );
      const { onWheel } = useWheel(
        {
          atStartEdge: computed(() => states.value.scrollOffset <= 0),
          atEndEdge: computed(
            () => states.value.scrollOffset >= estimatedTotalSize.value
          ),
          layout: computed(() => props.layout)
        },
        (offset) => {
          var _a, _b;
          (_b = (_a = scrollbarRef.value).onMouseUp) == null ? void 0 : _b.call(_a);
          scrollTo(
            Math.min(
              states.value.scrollOffset + offset,
              estimatedTotalSize.value - clientSize.value
            )
          );
        }
      );
      useEventListener(windowRef, "wheel", onWheel, {
        passive: false
      });
      const emitEvents = () => {
        const { total: total2 } = props;
        if (total2 > 0) {
          const [cacheStart, cacheEnd, visibleStart, visibleEnd] = unref(itemsToRender);
          emit(ITEM_RENDER_EVT, cacheStart, cacheEnd, visibleStart, visibleEnd);
        }
        const { scrollDir, scrollOffset, updateRequested } = unref(states);
        emit(SCROLL_EVT, scrollDir, scrollOffset, updateRequested);
      };
      const scrollVertically = (e12) => {
        const { clientHeight, scrollHeight, scrollTop } = e12.currentTarget;
        const _states = unref(states);
        if (_states.scrollOffset === scrollTop) {
          return;
        }
        const scrollOffset = Math.max(
          0,
          Math.min(scrollTop, scrollHeight - clientHeight)
        );
        states.value = {
          ..._states,
          isScrolling: true,
          scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),
          scrollOffset,
          updateRequested: false
        };
        nextTick(resetIsScrolling);
      };
      const scrollHorizontally = (e12) => {
        const { clientWidth, scrollLeft, scrollWidth } = e12.currentTarget;
        const _states = unref(states);
        if (_states.scrollOffset === scrollLeft) {
          return;
        }
        const { direction: direction2 } = props;
        let scrollOffset = scrollLeft;
        if (direction2 === RTL) {
          switch (getRTLOffsetType()) {
            case RTL_OFFSET_NAG: {
              scrollOffset = -scrollLeft;
              break;
            }
            case RTL_OFFSET_POS_DESC: {
              scrollOffset = scrollWidth - clientWidth - scrollLeft;
              break;
            }
          }
        }
        scrollOffset = Math.max(
          0,
          Math.min(scrollOffset, scrollWidth - clientWidth)
        );
        states.value = {
          ..._states,
          isScrolling: true,
          scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),
          scrollOffset,
          updateRequested: false
        };
        nextTick(resetIsScrolling);
      };
      const onScroll = (e12) => {
        unref(_isHorizontal) ? scrollHorizontally(e12) : scrollVertically(e12);
        emitEvents();
      };
      const onScrollbarScroll = (distanceToGo, totalSteps) => {
        const offset = (estimatedTotalSize.value - clientSize.value) / totalSteps * distanceToGo;
        scrollTo(
          Math.min(
            estimatedTotalSize.value - clientSize.value,
            offset
          )
        );
      };
      const scrollTo = (offset) => {
        offset = Math.max(offset, 0);
        if (offset === unref(states).scrollOffset) {
          return;
        }
        states.value = {
          ...unref(states),
          scrollOffset: offset,
          scrollDir: getScrollDir(unref(states).scrollOffset, offset),
          updateRequested: true
        };
        nextTick(resetIsScrolling);
      };
      const scrollToItem = (idx, alignment = AUTO_ALIGNMENT) => {
        const { scrollOffset } = unref(states);
        idx = Math.max(0, Math.min(idx, props.total - 1));
        scrollTo(
          getOffset2(
            props,
            idx,
            alignment,
            scrollOffset,
            unref(dynamicSizeCache)
          )
        );
      };
      const getItemStyle = (idx) => {
        const { direction: direction2, itemSize: itemSize2, layout: layout2 } = props;
        const itemStyleCache = getItemStyleCache.value(
          clearCache && itemSize2,
          clearCache && layout2,
          clearCache && direction2
        );
        let style;
        if (hasOwn(itemStyleCache, String(idx))) {
          style = itemStyleCache[idx];
        } else {
          const offset = getItemOffset(props, idx, unref(dynamicSizeCache));
          const size = getItemSize(props, idx, unref(dynamicSizeCache));
          const horizontal = unref(_isHorizontal);
          const isRtl = direction2 === RTL;
          const offsetHorizontal = horizontal ? offset : 0;
          itemStyleCache[idx] = style = {
            position: "absolute",
            left: isRtl ? void 0 : `${offsetHorizontal}px`,
            right: isRtl ? `${offsetHorizontal}px` : void 0,
            top: !horizontal ? `${offset}px` : 0,
            height: !horizontal ? `${size}px` : "100%",
            width: horizontal ? `${size}px` : "100%"
          };
        }
        return style;
      };
      const resetIsScrolling = () => {
        states.value.isScrolling = false;
        nextTick(() => {
          getItemStyleCache.value(-1, null, null);
        });
      };
      const resetScrollTop = () => {
        const window = windowRef.value;
        if (window) {
          window.scrollTop = 0;
        }
      };
      const api = {
        ns,
        clientSize,
        estimatedTotalSize,
        windowStyle,
        windowRef,
        innerRef,
        innerStyle,
        itemsToRender,
        scrollbarRef,
        states,
        getItemStyle,
        onScroll,
        onScrollbarScroll,
        onWheel,
        scrollTo,
        scrollToItem,
        resetScrollTop
      };
      expose({
        windowRef,
        innerRef,
        getItemStyleCache,
        scrollTo,
        scrollToItem,
        resetScrollTop,
        states
      });
      return api;
    },
    render(ctx) {
      var _a;
      const {
        $slots,
        className,
        clientSize,
        containerElement,
        data,
        getItemStyle,
        innerElement,
        itemsToRender,
        innerStyle,
        layout: layout2,
        total: total2,
        onScroll,
        onScrollbarScroll,
        states,
        useIsScrolling,
        windowStyle,
        ns
      } = ctx;
      const [start, end] = itemsToRender;
      const Container = resolveDynamicComponent(containerElement);
      const Inner = resolveDynamicComponent(innerElement);
      const children = [];
      if (total2 > 0) {
        for (let i8 = start; i8 <= end; i8++) {
          children.push(
            h(
              Fragment,
              { key: i8 },
              (_a = $slots.default) == null ? void 0 : _a.call($slots, {
                data,
                index: i8,
                isScrolling: useIsScrolling ? states.isScrolling : void 0,
                style: getItemStyle(i8)
              })
            )
          );
        }
      }
      const InnerNode = [
        h(
          Inner,
          mergeProps(ctx.innerProps, {
            style: innerStyle,
            ref: "innerRef"
          }),
          !isString(Inner) ? {
            default: () => children
          } : children
        )
      ];
      const scrollbar = h(ScrollBar, {
        ref: "scrollbarRef",
        clientSize,
        layout: layout2,
        onScroll: onScrollbarScroll,
        ratio: clientSize * 100 / this.estimatedTotalSize,
        scrollFrom: states.scrollOffset / (this.estimatedTotalSize - clientSize),
        total: total2,
        alwaysOn: states.scrollbarAlwaysOn
      });
      const listContainer = h(
        Container,
        {
          class: [ns.e("window"), className],
          style: windowStyle,
          onScroll,
          ref: "windowRef",
          key: 0
        },
        !isString(Container) ? { default: () => [InnerNode] } : [InnerNode]
      );
      return h(
        "div",
        {
          key: 0,
          class: [ns.e("wrapper"), states.scrollbarAlwaysOn ? "always-on" : ""]
        },
        [listContainer, scrollbar]
      );
    }
  });
};
createList({
  name: "ElFixedSizeList",
  getItemOffset: ({ itemSize: itemSize2 }, index) => index * itemSize2,
  getItemSize: ({ itemSize: itemSize2 }) => itemSize2,
  getEstimatedTotalSize: ({ total: total2, itemSize: itemSize2 }) => itemSize2 * total2,
  getOffset: ({ height, total: total2, itemSize: itemSize2, layout: layout2, width }, index, alignment, scrollOffset) => {
    const size = isHorizontal(layout2) ? width : height;
    const lastItemOffset = Math.max(0, total2 * itemSize2 - size);
    const maxOffset = Math.min(lastItemOffset, index * itemSize2);
    const minOffset = Math.max(0, (index + 1) * itemSize2 - size);
    if (alignment === SMART_ALIGNMENT) {
      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {
        alignment = AUTO_ALIGNMENT;
      } else {
        alignment = CENTERED_ALIGNMENT;
      }
    }
    switch (alignment) {
      case START_ALIGNMENT: {
        return maxOffset;
      }
      case END_ALIGNMENT: {
        return minOffset;
      }
      case CENTERED_ALIGNMENT: {
        const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);
        if (middleOffset < Math.ceil(size / 2)) {
          return 0;
        } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {
          return lastItemOffset;
        } else {
          return middleOffset;
        }
      }
      case AUTO_ALIGNMENT:
      default: {
        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {
          return scrollOffset;
        } else if (scrollOffset < minOffset) {
          return minOffset;
        } else {
          return maxOffset;
        }
      }
    }
  },
  getStartIndexForOffset: ({ total: total2, itemSize: itemSize2 }, offset) => Math.max(0, Math.min(total2 - 1, Math.floor(offset / itemSize2))),
  getStopIndexForStartIndex: ({ height, total: total2, itemSize: itemSize2, layout: layout2, width }, startIndex, scrollOffset) => {
    const offset = startIndex * itemSize2;
    const size = isHorizontal(layout2) ? width : height;
    const numVisibleItems = Math.ceil(
      (size + scrollOffset - offset) / itemSize2
    );
    return Math.max(
      0,
      Math.min(
        total2 - 1,
        startIndex + numVisibleItems - 1
      )
    );
  },
  initCache() {
    return void 0;
  },
  clearCache: true,
  validateProps() {
  }
});
const getItemFromCache$1 = (props, index, listCache) => {
  const { itemSize: itemSize2 } = props;
  const { items, lastVisitedIndex } = listCache;
  if (index > lastVisitedIndex) {
    let offset = 0;
    if (lastVisitedIndex >= 0) {
      const item = items[lastVisitedIndex];
      offset = item.offset + item.size;
    }
    for (let i8 = lastVisitedIndex + 1; i8 <= index; i8++) {
      const size = itemSize2(i8);
      items[i8] = {
        offset,
        size
      };
      offset += size;
    }
    listCache.lastVisitedIndex = index;
  }
  return items[index];
};
const findItem$1 = (props, listCache, offset) => {
  const { items, lastVisitedIndex } = listCache;
  const lastVisitedOffset = lastVisitedIndex > 0 ? items[lastVisitedIndex].offset : 0;
  if (lastVisitedOffset >= offset) {
    return bs$1(props, listCache, 0, lastVisitedIndex, offset);
  }
  return es$1(props, listCache, Math.max(0, lastVisitedIndex), offset);
};
const bs$1 = (props, listCache, low, high, offset) => {
  while (low <= high) {
    const mid = low + Math.floor((high - low) / 2);
    const currentOffset = getItemFromCache$1(props, mid, listCache).offset;
    if (currentOffset === offset) {
      return mid;
    } else if (currentOffset < offset) {
      low = mid + 1;
    } else if (currentOffset > offset) {
      high = mid - 1;
    }
  }
  return Math.max(0, low - 1);
};
const es$1 = (props, listCache, index, offset) => {
  const { total: total2 } = props;
  let exponent = 1;
  while (index < total2 && getItemFromCache$1(props, index, listCache).offset < offset) {
    index += exponent;
    exponent *= 2;
  }
  return bs$1(
    props,
    listCache,
    Math.floor(index / 2),
    Math.min(index, total2 - 1),
    offset
  );
};
const getEstimatedTotalSize = ({ total: total2 }, { items, estimatedItemSize: estimatedItemSize2, lastVisitedIndex }) => {
  let totalSizeOfMeasuredItems = 0;
  if (lastVisitedIndex >= total2) {
    lastVisitedIndex = total2 - 1;
  }
  if (lastVisitedIndex >= 0) {
    const item = items[lastVisitedIndex];
    totalSizeOfMeasuredItems = item.offset + item.size;
  }
  const numUnmeasuredItems = total2 - lastVisitedIndex - 1;
  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize2;
  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;
};
createList({
  name: "ElDynamicSizeList",
  getItemOffset: (props, index, listCache) => getItemFromCache$1(props, index, listCache).offset,
  getItemSize: (_, index, { items }) => items[index].size,
  getEstimatedTotalSize,
  getOffset: (props, index, alignment, scrollOffset, listCache) => {
    const { height, layout: layout2, width } = props;
    const size = isHorizontal(layout2) ? width : height;
    const item = getItemFromCache$1(props, index, listCache);
    const estimatedTotalSize = getEstimatedTotalSize(props, listCache);
    const maxOffset = Math.max(
      0,
      Math.min(estimatedTotalSize - size, item.offset)
    );
    const minOffset = Math.max(0, item.offset - size + item.size);
    if (alignment === SMART_ALIGNMENT) {
      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {
        alignment = AUTO_ALIGNMENT;
      } else {
        alignment = CENTERED_ALIGNMENT;
      }
    }
    switch (alignment) {
      case START_ALIGNMENT: {
        return maxOffset;
      }
      case END_ALIGNMENT: {
        return minOffset;
      }
      case CENTERED_ALIGNMENT: {
        return Math.round(minOffset + (maxOffset - minOffset) / 2);
      }
      case AUTO_ALIGNMENT:
      default: {
        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {
          return scrollOffset;
        } else if (scrollOffset < minOffset) {
          return minOffset;
        } else {
          return maxOffset;
        }
      }
    }
  },
  getStartIndexForOffset: (props, offset, listCache) => findItem$1(props, listCache, offset),
  getStopIndexForStartIndex: (props, startIndex, scrollOffset, listCache) => {
    const { height, total: total2, layout: layout2, width } = props;
    const size = isHorizontal(layout2) ? width : height;
    const item = getItemFromCache$1(props, startIndex, listCache);
    const maxOffset = scrollOffset + size;
    let offset = item.offset + item.size;
    let stopIndex = startIndex;
    while (stopIndex < total2 - 1 && offset < maxOffset) {
      stopIndex++;
      offset += getItemFromCache$1(props, stopIndex, listCache).size;
    }
    return stopIndex;
  },
  initCache({ estimatedItemSize: estimatedItemSize2 = DEFAULT_DYNAMIC_LIST_ITEM_SIZE }, instance) {
    const cache2 = {
      items: {},
      estimatedItemSize: estimatedItemSize2,
      lastVisitedIndex: -1
    };
    cache2.clearCacheAfterIndex = (index, forceUpdate = true) => {
      var _a, _b;
      cache2.lastVisitedIndex = Math.min(cache2.lastVisitedIndex, index - 1);
      (_a = instance.exposed) == null ? void 0 : _a.getItemStyleCache(-1);
      if (forceUpdate) {
        (_b = instance.proxy) == null ? void 0 : _b.$forceUpdate();
      }
    };
    return cache2;
  },
  clearCache: false,
  validateProps: ({ itemSize: itemSize2 }) => {
  }
});
const spaceItemProps = buildProps({
  prefixCls: {
    type: String
  }
});
const SpaceItem = defineComponent({
  name: "ElSpaceItem",
  props: spaceItemProps,
  setup(props, { slots }) {
    const ns = useNamespace("space");
    const classes = computed(() => `${props.prefixCls || ns.b()}__item`);
    return () => h("div", { class: classes.value }, renderSlot(slots, "default"));
  }
});
const SIZE_MAP = {
  small: 8,
  default: 12,
  large: 16
};
function useSpace(props) {
  const ns = useNamespace("space");
  const classes = computed(() => [ns.b(), ns.m(props.direction), props.class]);
  const horizontalSize = ref(0);
  const verticalSize = ref(0);
  const containerStyle = computed(() => {
    const wrapKls = props.wrap || props.fill ? { flexWrap: "wrap" } : {};
    const alignment = {
      alignItems: props.alignment
    };
    const gap = {
      rowGap: `${verticalSize.value}px`,
      columnGap: `${horizontalSize.value}px`
    };
    return [wrapKls, alignment, gap, props.style];
  });
  const itemStyle = computed(() => {
    return props.fill ? { flexGrow: 1, minWidth: `${props.fillRatio}%` } : {};
  });
  watchEffect(() => {
    const { size = "small", wrap, direction: dir, fill } = props;
    if (isArray(size)) {
      const [h7 = 0, v6 = 0] = size;
      horizontalSize.value = h7;
      verticalSize.value = v6;
    } else {
      let val;
      if (isNumber$1(size)) {
        val = size;
      } else {
        val = SIZE_MAP[size || "small"] || SIZE_MAP.small;
      }
      if ((wrap || fill) && dir === "horizontal") {
        horizontalSize.value = verticalSize.value = val;
      } else {
        if (dir === "horizontal") {
          horizontalSize.value = val;
          verticalSize.value = 0;
        } else {
          verticalSize.value = val;
          horizontalSize.value = 0;
        }
      }
    }
  });
  return {
    classes,
    containerStyle,
    itemStyle
  };
}
const spaceProps = buildProps({
  direction: {
    type: String,
    values: ["horizontal", "vertical"],
    default: "horizontal"
  },
  class: {
    type: definePropType([
      String,
      Object,
      Array
    ]),
    default: ""
  },
  style: {
    type: definePropType([String, Array, Object]),
    default: ""
  },
  alignment: {
    type: definePropType(String),
    default: "center"
  },
  prefixCls: {
    type: String
  },
  spacer: {
    type: definePropType([Object, String, Number, Array]),
    default: null,
    validator: (val) => isVNode(val) || isNumber$1(val) || isString(val)
  },
  wrap: Boolean,
  fill: Boolean,
  fillRatio: {
    type: Number,
    default: 100
  },
  size: {
    type: [String, Array, Number],
    values: componentSizes,
    validator: (val) => {
      return isNumber$1(val) || isArray(val) && val.length === 2 && val.every(isNumber$1);
    }
  }
});
defineComponent({
  name: "ElSpace",
  props: spaceProps,
  setup(props, { slots }) {
    const { classes, containerStyle, itemStyle } = useSpace(props);
    function extractChildren(children, parentKey = "", extractedChildren = []) {
      const { prefixCls } = props;
      children.forEach((child, loopKey) => {
        if (isFragment(child)) {
          if (isArray(child.children)) {
            child.children.forEach((nested, key) => {
              if (isFragment(nested) && isArray(nested.children)) {
                extractChildren(
                  nested.children,
                  `${parentKey + key}-`,
                  extractedChildren
                );
              } else {
                if (isVNode(nested) && (nested == null ? void 0 : nested.type) === Comment) {
                  extractedChildren.push(nested);
                } else {
                  extractedChildren.push(
                    createVNode(
                      SpaceItem,
                      {
                        style: itemStyle.value,
                        prefixCls,
                        key: `nested-${parentKey + key}`
                      },
                      {
                        default: () => [nested]
                      },
                      PatchFlags.PROPS | PatchFlags.STYLE,
                      ["style", "prefixCls"]
                    )
                  );
                }
              }
            });
          }
        } else if (isValidElementNode(child)) {
          extractedChildren.push(
            createVNode(
              SpaceItem,
              {
                style: itemStyle.value,
                prefixCls,
                key: `LoopKey${parentKey + loopKey}`
              },
              {
                default: () => [child]
              },
              PatchFlags.PROPS | PatchFlags.STYLE,
              ["style", "prefixCls"]
            )
          );
        }
      });
      return extractedChildren;
    }
    return () => {
      var _a;
      const { spacer, direction: direction2 } = props;
      const children = renderSlot(slots, "default", { key: 0 }, () => []);
      if (((_a = children.children) != null ? _a : []).length === 0)
        return null;
      if (isArray(children.children)) {
        let extractedChildren = extractChildren(children.children);
        if (spacer) {
          const len = extractedChildren.length - 1;
          extractedChildren = extractedChildren.reduce(
            (acc, child, idx) => {
              const children2 = [...acc, child];
              if (idx !== len) {
                children2.push(
                  createVNode(
                    "span",
                    {
                      style: [
                        itemStyle.value,
                        direction2 === "vertical" ? "width: 100%" : null
                      ],
                      key: idx
                    },
                    [
                      isVNode(spacer) ? spacer : createTextVNode(spacer, PatchFlags.TEXT)
                    ],
                    PatchFlags.STYLE
                  )
                );
              }
              return children2;
            },
            []
          );
        }
        return createVNode(
          "div",
          {
            class: classes.value,
            style: containerStyle.value
          },
          extractedChildren,
          PatchFlags.STYLE | PatchFlags.CLASS
        );
      }
      return children.children;
    };
  }
});
buildProps({
  format: {
    type: String,
    default: "HH:mm:ss"
  },
  prefix: String,
  suffix: String,
  title: String,
  value: {
    type: definePropType([Number, Object]),
    default: 0
  },
  valueStyle: {
    type: definePropType([String, Object, Array])
  }
});
var SortOrder = /* @__PURE__ */ ((SortOrder2) => {
  SortOrder2["ASC"] = "asc";
  SortOrder2["DESC"] = "desc";
  return SortOrder2;
})(SortOrder || {});
var Alignment = /* @__PURE__ */ ((Alignment2) => {
  Alignment2["LEFT"] = "left";
  Alignment2["CENTER"] = "center";
  Alignment2["RIGHT"] = "right";
  return Alignment2;
})(Alignment || {});
var FixedDir = /* @__PURE__ */ ((FixedDir2) => {
  FixedDir2["LEFT"] = "left";
  FixedDir2["RIGHT"] = "right";
  return FixedDir2;
})(FixedDir || {});
const oppositeOrderMap = {
  [
    "asc"
    /* ASC */
  ]: "desc",
  [
    "desc"
    /* DESC */
  ]: "asc"
  /* ASC */
};
const placeholderSign = /* @__PURE__ */ Symbol("placeholder");
const calcColumnStyle = (column, fixedColumn, fixed) => {
  var _a, _b, _c;
  const flex = {
    flexGrow: 0,
    flexShrink: 0,
    ...fixed ? {} : {
      flexGrow: (_a = column.flexGrow) != null ? _a : 0,
      flexShrink: (_b = column.flexShrink) != null ? _b : 1
    }
  };
  const style = {
    ...(_c = column.style) != null ? _c : {},
    ...flex,
    flexBasis: "auto",
    width: column.width
  };
  if (!fixedColumn) {
    if (column.maxWidth)
      style.maxWidth = column.maxWidth;
    if (column.minWidth)
      style.minWidth = column.minWidth;
  }
  return style;
};
function useColumns(props, columns2, fixed) {
  const _columns = computed(
    () => unref(columns2).map((column, index) => {
      var _a, _b;
      return {
        ...column,
        key: (_b = (_a = column.key) != null ? _a : column.dataKey) != null ? _b : index
      };
    })
  );
  const visibleColumns = computed(() => {
    return unref(_columns).filter((column) => !column.hidden);
  });
  const fixedColumnsOnLeft = computed(
    () => unref(visibleColumns).filter(
      (column) => column.fixed === "left" || column.fixed === true
    )
  );
  const fixedColumnsOnRight = computed(
    () => unref(visibleColumns).filter((column) => column.fixed === "right")
  );
  const normalColumns = computed(
    () => unref(visibleColumns).filter((column) => !column.fixed)
  );
  const mainColumns = computed(() => {
    const ret = [];
    unref(fixedColumnsOnLeft).forEach((column) => {
      ret.push({
        ...column,
        placeholderSign
      });
    });
    unref(normalColumns).forEach((column) => {
      ret.push(column);
    });
    unref(fixedColumnsOnRight).forEach((column) => {
      ret.push({
        ...column,
        placeholderSign
      });
    });
    return ret;
  });
  const hasFixedColumns = computed(() => {
    return unref(fixedColumnsOnLeft).length || unref(fixedColumnsOnRight).length;
  });
  const columnsStyles = computed(() => {
    return unref(_columns).reduce(
      (style, column) => {
        style[column.key] = calcColumnStyle(column, unref(fixed), props.fixed);
        return style;
      },
      {}
    );
  });
  const columnsTotalWidth = computed(() => {
    return unref(visibleColumns).reduce(
      (width, column) => width + column.width,
      0
    );
  });
  const getColumn = (key) => {
    return unref(_columns).find((column) => column.key === key);
  };
  const getColumnStyle = (key) => {
    return unref(columnsStyles)[key];
  };
  const updateColumnWidth = (column, width) => {
    column.width = width;
  };
  function onColumnSorted(e12) {
    var _a;
    const { key } = e12.currentTarget.dataset;
    if (!key)
      return;
    const { sortState, sortBy } = props;
    let order = SortOrder.ASC;
    if (isObject(sortState)) {
      order = oppositeOrderMap[sortState[key]];
    } else {
      order = oppositeOrderMap[sortBy.order];
    }
    (_a = props.onColumnSort) == null ? void 0 : _a.call(props, { column: getColumn(key), key, order });
  }
  return {
    columns: _columns,
    columnsStyles,
    columnsTotalWidth,
    fixedColumnsOnLeft,
    fixedColumnsOnRight,
    hasFixedColumns,
    mainColumns,
    normalColumns,
    visibleColumns,
    getColumn,
    getColumnStyle,
    updateColumnWidth,
    onColumnSorted
  };
}
const useScrollbar = (props, {
  mainTableRef,
  leftTableRef,
  rightTableRef,
  onMaybeEndReached
}) => {
  const scrollPos = ref({ scrollLeft: 0, scrollTop: 0 });
  function doScroll(params) {
    var _a, _b, _c;
    const { scrollTop } = params;
    (_a = mainTableRef.value) == null ? void 0 : _a.scrollTo(params);
    (_b = leftTableRef.value) == null ? void 0 : _b.scrollToTop(scrollTop);
    (_c = rightTableRef.value) == null ? void 0 : _c.scrollToTop(scrollTop);
  }
  function scrollTo(params) {
    scrollPos.value = params;
    doScroll(params);
  }
  function scrollToTop(scrollTop) {
    scrollPos.value.scrollTop = scrollTop;
    doScroll(unref(scrollPos));
  }
  function scrollToLeft(scrollLeft) {
    var _a, _b;
    scrollPos.value.scrollLeft = scrollLeft;
    (_b = (_a = mainTableRef.value) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, unref(scrollPos));
  }
  function onScroll(params) {
    var _a;
    scrollTo(params);
    (_a = props.onScroll) == null ? void 0 : _a.call(props, params);
  }
  function onVerticalScroll({ scrollTop }) {
    const { scrollTop: currentScrollTop } = unref(scrollPos);
    if (scrollTop !== currentScrollTop)
      scrollToTop(scrollTop);
  }
  function scrollToRow(row, strategy = "auto") {
    var _a;
    (_a = mainTableRef.value) == null ? void 0 : _a.scrollToRow(row, strategy);
  }
  watch(
    () => unref(scrollPos).scrollTop,
    (cur, prev) => {
      if (cur > prev)
        onMaybeEndReached();
    }
  );
  return {
    scrollPos,
    scrollTo,
    scrollToLeft,
    scrollToTop,
    scrollToRow,
    onScroll,
    onVerticalScroll
  };
};
const useRow = (props, {
  mainTableRef,
  leftTableRef,
  rightTableRef,
  tableInstance,
  ns,
  isScrolling
}) => {
  const vm = getCurrentInstance();
  const { emit } = vm;
  const isResetting = shallowRef(false);
  const expandedRowKeys = ref(props.defaultExpandedRowKeys || []);
  const lastRenderedRowIndex = ref(-1);
  const resetIndex = shallowRef(null);
  const rowHeights = ref({});
  const pendingRowHeights = ref({});
  const leftTableHeights = shallowRef({});
  const mainTableHeights = shallowRef({});
  const rightTableHeights = shallowRef({});
  const isDynamic = computed(() => isNumber$1(props.estimatedRowHeight));
  function onRowsRendered(params) {
    var _a;
    (_a = props.onRowsRendered) == null ? void 0 : _a.call(props, params);
    if (params.rowCacheEnd > unref(lastRenderedRowIndex)) {
      lastRenderedRowIndex.value = params.rowCacheEnd;
    }
  }
  function onRowHovered({ hovered, rowKey: rowKey2 }) {
    if (isScrolling.value) {
      return;
    }
    const tableRoot = tableInstance.vnode.el;
    const rows = tableRoot.querySelectorAll(`[rowkey="${String(rowKey2)}"]`);
    rows.forEach((row) => {
      if (hovered) {
        row.classList.add(ns.is("hovered"));
      } else {
        row.classList.remove(ns.is("hovered"));
      }
    });
  }
  function onRowExpanded({
    expanded,
    rowData,
    rowIndex,
    rowKey: rowKey2
  }) {
    var _a, _b;
    const _expandedRowKeys = [...unref(expandedRowKeys)];
    const currentKeyIndex = _expandedRowKeys.indexOf(rowKey2);
    if (expanded) {
      if (currentKeyIndex === -1)
        _expandedRowKeys.push(rowKey2);
    } else {
      if (currentKeyIndex > -1)
        _expandedRowKeys.splice(currentKeyIndex, 1);
    }
    expandedRowKeys.value = _expandedRowKeys;
    emit("update:expandedRowKeys", _expandedRowKeys);
    (_a = props.onRowExpand) == null ? void 0 : _a.call(props, {
      expanded,
      rowData,
      rowIndex,
      rowKey: rowKey2
    });
    (_b = props.onExpandedRowsChange) == null ? void 0 : _b.call(props, _expandedRowKeys);
    const tableRoot = tableInstance.vnode.el;
    const hoverRow = tableRoot.querySelector(
      `.${ns.is("hovered")}[rowkey="${String(rowKey2)}"]`
    );
    if (hoverRow) {
      nextTick(() => onRowHovered({ hovered: true, rowKey: rowKey2 }));
    }
  }
  const flushingRowHeights = debounce(() => {
    var _a, _b, _c, _d;
    isResetting.value = true;
    rowHeights.value = { ...unref(rowHeights), ...unref(pendingRowHeights) };
    resetAfterIndex(unref(resetIndex), false);
    pendingRowHeights.value = {};
    resetIndex.value = null;
    (_a = mainTableRef.value) == null ? void 0 : _a.forceUpdate();
    (_b = leftTableRef.value) == null ? void 0 : _b.forceUpdate();
    (_c = rightTableRef.value) == null ? void 0 : _c.forceUpdate();
    (_d = vm.proxy) == null ? void 0 : _d.$forceUpdate();
    isResetting.value = false;
  }, 0);
  function resetAfterIndex(index, forceUpdate = false) {
    if (!unref(isDynamic))
      return;
    [mainTableRef, leftTableRef, rightTableRef].forEach((tableRef) => {
      const table = unref(tableRef);
      if (table)
        table.resetAfterRowIndex(index, forceUpdate);
    });
  }
  function resetHeights(rowKey2, height, rowIdx) {
    const resetIdx = unref(resetIndex);
    if (resetIdx === null) {
      resetIndex.value = rowIdx;
    } else {
      if (resetIdx > rowIdx) {
        resetIndex.value = rowIdx;
      }
    }
    pendingRowHeights.value[rowKey2] = height;
  }
  function onRowHeightChange({ rowKey: rowKey2, height, rowIndex }, fixedDir) {
    if (!fixedDir) {
      mainTableHeights.value[rowKey2] = height;
    } else {
      if (fixedDir === FixedDir.RIGHT) {
        rightTableHeights.value[rowKey2] = height;
      } else {
        leftTableHeights.value[rowKey2] = height;
      }
    }
    const maximumHeight = Math.max(
      ...[leftTableHeights, rightTableHeights, mainTableHeights].map(
        (records) => records.value[rowKey2] || 0
      )
    );
    if (unref(rowHeights)[rowKey2] !== maximumHeight) {
      resetHeights(rowKey2, maximumHeight, rowIndex);
      flushingRowHeights();
    }
  }
  return {
    expandedRowKeys,
    lastRenderedRowIndex,
    isDynamic,
    isResetting,
    rowHeights,
    resetAfterIndex,
    onRowExpanded,
    onRowHovered,
    onRowsRendered,
    onRowHeightChange
  };
};
const useData = (props, { expandedRowKeys, lastRenderedRowIndex, resetAfterIndex }) => {
  const depthMap = ref({});
  const flattenedData = computed(() => {
    const depths = {};
    const { data: data2, rowKey: rowKey2 } = props;
    const _expandedRowKeys = unref(expandedRowKeys);
    if (!_expandedRowKeys || !_expandedRowKeys.length)
      return data2;
    const array = [];
    const keysSet = /* @__PURE__ */ new Set();
    _expandedRowKeys.forEach((x2) => keysSet.add(x2));
    let copy = data2.slice();
    copy.forEach((x2) => depths[x2[rowKey2]] = 0);
    while (copy.length > 0) {
      const item = copy.shift();
      array.push(item);
      if (keysSet.has(item[rowKey2]) && isArray(item.children) && item.children.length > 0) {
        copy = [...item.children, ...copy];
        item.children.forEach(
          (child) => depths[child[rowKey2]] = depths[item[rowKey2]] + 1
        );
      }
    }
    depthMap.value = depths;
    return array;
  });
  const data = computed(() => {
    const { data: data2, expandColumnKey: expandColumnKey2 } = props;
    return expandColumnKey2 ? unref(flattenedData) : data2;
  });
  watch(data, (val, prev) => {
    if (val !== prev) {
      lastRenderedRowIndex.value = -1;
      resetAfterIndex(0, true);
    }
  });
  return {
    data,
    depthMap
  };
};
const sumReducer = (sum2, num) => sum2 + num;
const sum = (listLike) => {
  return isArray(listLike) ? listLike.reduce(sumReducer, 0) : listLike;
};
const tryCall = (fLike, params, defaultRet = {}) => {
  return isFunction(fLike) ? fLike(params) : fLike != null ? fLike : defaultRet;
};
const enforceUnit = (style) => {
  ["width", "maxWidth", "minWidth", "height"].forEach((key) => {
    style[key] = addUnit(style[key]);
  });
  return style;
};
const componentToSlot = (ComponentLike) => isVNode(ComponentLike) ? (props) => h(ComponentLike, props) : ComponentLike;
const useStyles = (props, {
  columnsTotalWidth,
  rowsHeight,
  fixedColumnsOnLeft,
  fixedColumnsOnRight
}) => {
  const bodyWidth = computed(() => {
    const { fixed, width, vScrollbarSize } = props;
    const ret = width - vScrollbarSize;
    return fixed ? Math.max(Math.round(unref(columnsTotalWidth)), ret) : ret;
  });
  const mainTableHeight = computed(() => {
    const { height = 0, maxHeight = 0, footerHeight: footerHeight2, hScrollbarSize } = props;
    if (maxHeight > 0) {
      const _fixedRowsHeight = unref(fixedRowsHeight);
      const _rowsHeight = unref(rowsHeight);
      const _headerHeight = unref(headerHeight);
      const total2 = _headerHeight + _fixedRowsHeight + _rowsHeight + hScrollbarSize;
      return Math.min(total2, maxHeight - footerHeight2);
    }
    return height - footerHeight2;
  });
  const fixedTableHeight = computed(() => {
    const { maxHeight } = props;
    const tableHeight = unref(mainTableHeight);
    if (isNumber$1(maxHeight) && maxHeight > 0)
      return tableHeight;
    const totalHeight = unref(rowsHeight) + unref(headerHeight) + unref(fixedRowsHeight);
    return Math.min(tableHeight, totalHeight);
  });
  const mapColumn = (column) => column.width;
  const leftTableWidth = computed(
    () => sum(unref(fixedColumnsOnLeft).map(mapColumn))
  );
  const rightTableWidth = computed(
    () => sum(unref(fixedColumnsOnRight).map(mapColumn))
  );
  const headerHeight = computed(() => sum(props.headerHeight));
  const fixedRowsHeight = computed(() => {
    var _a;
    return (((_a = props.fixedData) == null ? void 0 : _a.length) || 0) * props.rowHeight;
  });
  const windowHeight = computed(() => {
    return unref(mainTableHeight) - unref(headerHeight) - unref(fixedRowsHeight);
  });
  const rootStyle = computed(() => {
    const { style = {}, height, width } = props;
    return enforceUnit({
      ...style,
      height,
      width
    });
  });
  const footerHeight = computed(
    () => enforceUnit({ height: props.footerHeight })
  );
  const emptyStyle = computed(() => ({
    top: addUnit(unref(headerHeight)),
    bottom: addUnit(props.footerHeight),
    width: addUnit(props.width)
  }));
  return {
    bodyWidth,
    fixedTableHeight,
    mainTableHeight,
    leftTableWidth,
    rightTableWidth,
    windowHeight,
    footerHeight,
    emptyStyle,
    rootStyle,
    headerHeight
  };
};
function useTable(props) {
  const mainTableRef = ref();
  const leftTableRef = ref();
  const rightTableRef = ref();
  const {
    columns: columns2,
    columnsStyles,
    columnsTotalWidth,
    fixedColumnsOnLeft,
    fixedColumnsOnRight,
    hasFixedColumns,
    mainColumns,
    onColumnSorted
  } = useColumns(props, toRef(props, "columns"), toRef(props, "fixed"));
  const {
    scrollTo,
    scrollToLeft,
    scrollToTop,
    scrollToRow,
    onScroll,
    onVerticalScroll,
    scrollPos
  } = useScrollbar(props, {
    mainTableRef,
    leftTableRef,
    rightTableRef,
    onMaybeEndReached
  });
  const ns = useNamespace("table-v2");
  const instance = getCurrentInstance();
  const isScrolling = shallowRef(false);
  const {
    expandedRowKeys,
    lastRenderedRowIndex,
    isDynamic,
    isResetting,
    rowHeights,
    resetAfterIndex,
    onRowExpanded,
    onRowHeightChange,
    onRowHovered,
    onRowsRendered
  } = useRow(props, {
    mainTableRef,
    leftTableRef,
    rightTableRef,
    tableInstance: instance,
    ns,
    isScrolling
  });
  const { data, depthMap } = useData(props, {
    expandedRowKeys,
    lastRenderedRowIndex,
    resetAfterIndex
  });
  const rowsHeight = computed(() => {
    const { estimatedRowHeight, rowHeight } = props;
    const _data = unref(data);
    if (isNumber$1(estimatedRowHeight)) {
      return Object.values(unref(rowHeights)).reduce(
        (acc, curr) => acc + curr,
        0
      );
    }
    return _data.length * rowHeight;
  });
  const {
    bodyWidth,
    fixedTableHeight,
    mainTableHeight,
    leftTableWidth,
    rightTableWidth,
    windowHeight,
    footerHeight,
    emptyStyle,
    rootStyle,
    headerHeight
  } = useStyles(props, {
    columnsTotalWidth,
    fixedColumnsOnLeft,
    fixedColumnsOnRight,
    rowsHeight
  });
  const containerRef = ref();
  const showEmpty = computed(() => {
    const noData = unref(data).length === 0;
    return isArray(props.fixedData) ? props.fixedData.length === 0 && noData : noData;
  });
  function getRowHeight(rowIndex) {
    const { estimatedRowHeight, rowHeight, rowKey: rowKey2 } = props;
    if (!estimatedRowHeight)
      return rowHeight;
    return unref(rowHeights)[unref(data)[rowIndex][rowKey2]] || estimatedRowHeight;
  }
  const isEndReached = ref(false);
  function onMaybeEndReached() {
    const { onEndReached } = props;
    if (!onEndReached)
      return;
    const { scrollTop } = unref(scrollPos);
    const _totalHeight = unref(rowsHeight);
    const clientHeight = unref(windowHeight);
    const remainDistance = _totalHeight - (scrollTop + clientHeight) + props.hScrollbarSize;
    if (!isEndReached.value && unref(lastRenderedRowIndex) >= 0 && _totalHeight <= scrollTop + unref(mainTableHeight) - unref(headerHeight)) {
      isEndReached.value = true;
      onEndReached(remainDistance);
    } else {
      isEndReached.value = false;
    }
  }
  watch(
    () => unref(rowsHeight),
    () => isEndReached.value = false
  );
  watch(
    () => props.expandedRowKeys,
    (val) => expandedRowKeys.value = val,
    {
      deep: true
    }
  );
  return {
    columns: columns2,
    containerRef,
    mainTableRef,
    leftTableRef,
    rightTableRef,
    isDynamic,
    isResetting,
    isScrolling,
    hasFixedColumns,
    columnsStyles,
    columnsTotalWidth,
    data,
    expandedRowKeys,
    depthMap,
    fixedColumnsOnLeft,
    fixedColumnsOnRight,
    mainColumns,
    bodyWidth,
    emptyStyle,
    rootStyle,
    footerHeight,
    mainTableHeight,
    fixedTableHeight,
    leftTableWidth,
    rightTableWidth,
    showEmpty,
    getRowHeight,
    onColumnSorted,
    onRowHovered,
    onRowExpanded,
    onRowsRendered,
    onRowHeightChange,
    scrollTo,
    scrollToLeft,
    scrollToTop,
    scrollToRow,
    onScroll,
    onVerticalScroll
  };
}
const TableV2InjectionKey = /* @__PURE__ */ Symbol("tableV2");
const TABLE_V2_GRID_INJECTION_KEY = "tableV2GridScrollLeft";
const classType = String;
const columns = {
  type: definePropType(Array),
  required: true
};
const fixedDataType = {
  type: definePropType(Array)
};
const dataType = {
  ...fixedDataType,
  required: true
};
const expandColumnKey = String;
const expandKeys = {
  type: definePropType(Array),
  default: () => mutable([])
};
const requiredNumber = {
  type: Number,
  required: true
};
const rowKey = {
  type: definePropType([String, Number, Symbol]),
  default: "id"
};
const styleType = {
  type: definePropType(Object)
};
const tableV2RowProps = buildProps({
  class: String,
  columns,
  columnsStyles: {
    type: definePropType(Object),
    required: true
  },
  depth: Number,
  expandColumnKey,
  estimatedRowHeight: {
    ...virtualizedGridProps.estimatedRowHeight,
    default: void 0
  },
  isScrolling: Boolean,
  onRowExpand: {
    type: definePropType(Function)
  },
  onRowHover: {
    type: definePropType(Function)
  },
  onRowHeightChange: {
    type: definePropType(Function)
  },
  rowData: {
    type: definePropType(Object),
    required: true
  },
  rowEventHandlers: {
    type: definePropType(Object)
  },
  rowIndex: {
    type: Number,
    required: true
  },
  rowKey,
  style: {
    type: definePropType(Object)
  }
});
const requiredNumberType = {
  type: Number,
  required: true
};
const tableV2HeaderProps = buildProps({
  class: String,
  columns,
  fixedHeaderData: {
    type: definePropType(Array)
  },
  headerData: {
    type: definePropType(Array),
    required: true
  },
  headerHeight: {
    type: definePropType([Number, Array]),
    default: 50
  },
  rowWidth: requiredNumberType,
  rowHeight: {
    type: Number,
    default: 50
  },
  height: requiredNumberType,
  width: requiredNumberType
});
const tableV2GridProps = buildProps({
  columns,
  data: dataType,
  fixedData: fixedDataType,
  estimatedRowHeight: tableV2RowProps.estimatedRowHeight,
  width: requiredNumber,
  height: requiredNumber,
  headerWidth: requiredNumber,
  headerHeight: tableV2HeaderProps.headerHeight,
  bodyWidth: requiredNumber,
  rowHeight: requiredNumber,
  cache: virtualizedListProps.cache,
  useIsScrolling: Boolean,
  scrollbarAlwaysOn: virtualizedGridProps.scrollbarAlwaysOn,
  scrollbarStartGap: virtualizedGridProps.scrollbarStartGap,
  scrollbarEndGap: virtualizedGridProps.scrollbarEndGap,
  class: classType,
  style: styleType,
  containerStyle: styleType,
  getRowHeight: {
    type: definePropType(Function),
    required: true
  },
  rowKey: tableV2RowProps.rowKey,
  onRowsRendered: {
    type: definePropType(Function)
  },
  onScroll: {
    type: definePropType(Function)
  }
});
const tableV2Props = buildProps({
  cache: tableV2GridProps.cache,
  estimatedRowHeight: tableV2RowProps.estimatedRowHeight,
  rowKey,
  headerClass: {
    type: definePropType([
      String,
      Function
    ])
  },
  headerProps: {
    type: definePropType([
      Object,
      Function
    ])
  },
  headerCellProps: {
    type: definePropType([
      Object,
      Function
    ])
  },
  headerHeight: tableV2HeaderProps.headerHeight,
  footerHeight: {
    type: Number,
    default: 0
  },
  rowClass: {
    type: definePropType([String, Function])
  },
  rowProps: {
    type: definePropType([Object, Function])
  },
  rowHeight: {
    type: Number,
    default: 50
  },
  cellProps: {
    type: definePropType([
      Object,
      Function
    ])
  },
  columns,
  data: dataType,
  dataGetter: {
    type: definePropType(Function)
  },
  fixedData: fixedDataType,
  expandColumnKey: tableV2RowProps.expandColumnKey,
  expandedRowKeys: expandKeys,
  defaultExpandedRowKeys: expandKeys,
  class: classType,
  fixed: Boolean,
  style: {
    type: definePropType(Object)
  },
  width: requiredNumber,
  height: requiredNumber,
  maxHeight: Number,
  useIsScrolling: Boolean,
  indentSize: {
    type: Number,
    default: 12
  },
  iconSize: {
    type: Number,
    default: 12
  },
  hScrollbarSize: virtualizedGridProps.hScrollbarSize,
  vScrollbarSize: virtualizedGridProps.vScrollbarSize,
  scrollbarAlwaysOn: virtualizedScrollbarProps.alwaysOn,
  sortBy: {
    type: definePropType(Object),
    default: () => ({})
  },
  sortState: {
    type: definePropType(Object),
    default: void 0
  },
  onColumnSort: {
    type: definePropType(Function)
  },
  onExpandedRowsChange: {
    type: definePropType(Function)
  },
  onEndReached: {
    type: definePropType(Function)
  },
  onRowExpand: tableV2RowProps.onRowExpand,
  onScroll: tableV2GridProps.onScroll,
  onRowsRendered: tableV2GridProps.onRowsRendered,
  rowEventHandlers: tableV2RowProps.rowEventHandlers
});
const COMPONENT_NAME$3 = "ElTableV2Header";
const TableV2Header = defineComponent({
  name: COMPONENT_NAME$3,
  props: tableV2HeaderProps,
  setup(props, {
    slots,
    expose
  }) {
    const ns = useNamespace("table-v2");
    inject(TABLE_V2_GRID_INJECTION_KEY);
    const headerRef = ref();
    const headerStyle = computed(() => enforceUnit({
      width: props.width,
      height: props.height
    }));
    const rowStyle = computed(() => enforceUnit({
      width: props.rowWidth,
      height: props.height
    }));
    const headerHeights = computed(() => castArray(unref(props.headerHeight)));
    const scrollToLeft = (left) => {
      const headerEl = unref(headerRef);
      nextTick(() => {
        (headerEl == null ? void 0 : headerEl.scroll) && headerEl.scroll({
          left
        });
      });
    };
    const renderFixedRows = () => {
      const fixedRowClassName = ns.e("fixed-header-row");
      const {
        columns: columns2,
        fixedHeaderData,
        rowHeight
      } = props;
      return fixedHeaderData == null ? void 0 : fixedHeaderData.map((fixedRowData, fixedRowIndex) => {
        var _a;
        const style = enforceUnit({
          height: rowHeight,
          width: "100%"
        });
        return (_a = slots.fixed) == null ? void 0 : _a.call(slots, {
          class: fixedRowClassName,
          columns: columns2,
          rowData: fixedRowData,
          rowIndex: -(fixedRowIndex + 1),
          style
        });
      });
    };
    const renderDynamicRows = () => {
      const dynamicRowClassName = ns.e("dynamic-header-row");
      const {
        columns: columns2
      } = props;
      return unref(headerHeights).map((rowHeight, rowIndex) => {
        var _a;
        const style = enforceUnit({
          width: "100%",
          height: rowHeight
        });
        return (_a = slots.dynamic) == null ? void 0 : _a.call(slots, {
          class: dynamicRowClassName,
          columns: columns2,
          headerIndex: rowIndex,
          style
        });
      });
    };
    expose({
      scrollToLeft
    });
    return () => {
      if (props.height <= 0)
        return;
      return createVNode("div", {
        "ref": headerRef,
        "class": props.class,
        "style": unref(headerStyle),
        "role": "rowgroup"
      }, [createVNode("div", {
        "style": unref(rowStyle),
        "class": ns.e("header")
      }, [renderDynamicRows(), renderFixedRows()])]);
    };
  }
});
var Header$1 = TableV2Header;
const useGridWheel = ({ atXEndEdge, atXStartEdge, atYEndEdge, atYStartEdge }, onWheelDelta) => {
  let frameHandle = null;
  let xOffset = 0;
  let yOffset = 0;
  const hasReachedEdge = (x2, y2) => {
    const xEdgeReached = x2 < 0 && atXStartEdge.value || x2 > 0 && atXEndEdge.value;
    const yEdgeReached = y2 < 0 && atYStartEdge.value || y2 > 0 && atYEndEdge.value;
    return xEdgeReached || yEdgeReached;
  };
  const onWheel = (e12) => {
    cAF(frameHandle);
    let x2 = e12.deltaX;
    let y2 = e12.deltaY;
    if (Math.abs(x2) > Math.abs(y2)) {
      y2 = 0;
    } else {
      x2 = 0;
    }
    if (e12.shiftKey && y2 !== 0) {
      x2 = y2;
      y2 = 0;
    }
    if (hasReachedEdge(x2, y2))
      return;
    xOffset += x2;
    yOffset += y2;
    e12.preventDefault();
    frameHandle = rAF(() => {
      onWheelDelta(xOffset, yOffset);
      xOffset = 0;
      yOffset = 0;
    });
  };
  return {
    hasReachedEdge,
    onWheel
  };
};
const useGridTouch = (windowRef, states, scrollTo, estimatedTotalWidth, estimatedTotalHeight, parsedWidth, parsedHeight) => {
  const touchStartX = ref(0);
  const touchStartY = ref(0);
  let frameHandle;
  let deltaX = 0;
  let deltaY = 0;
  const handleTouchStart = (event) => {
    cAF(frameHandle);
    touchStartX.value = event.touches[0].clientX;
    touchStartY.value = event.touches[0].clientY;
    deltaX = 0;
    deltaY = 0;
  };
  const handleTouchMove = (event) => {
    event.preventDefault();
    cAF(frameHandle);
    deltaX += touchStartX.value - event.touches[0].clientX;
    deltaY += touchStartY.value - event.touches[0].clientY;
    touchStartX.value = event.touches[0].clientX;
    touchStartY.value = event.touches[0].clientY;
    frameHandle = rAF(() => {
      const maxScrollLeft = estimatedTotalWidth.value - unref(parsedWidth);
      const maxScrollTop = estimatedTotalHeight.value - unref(parsedHeight);
      const safeScrollLeft = Math.min(
        states.value.scrollLeft + deltaX,
        maxScrollLeft
      );
      const safeScrollTop = Math.min(
        states.value.scrollTop + deltaY,
        maxScrollTop
      );
      scrollTo({
        scrollLeft: safeScrollLeft,
        scrollTop: safeScrollTop
      });
      deltaX = 0;
      deltaY = 0;
    });
  };
  useEventListener(windowRef, "touchstart", handleTouchStart, {
    passive: true
  });
  useEventListener(windowRef, "touchmove", handleTouchMove, {
    passive: false
  });
  return {
    touchStartX,
    touchStartY,
    handleTouchStart,
    handleTouchMove
  };
};
const createGrid = ({
  name,
  clearCache,
  getColumnPosition,
  getColumnStartIndexForOffset,
  getColumnStopIndexForStartIndex,
  getEstimatedTotalHeight: getEstimatedTotalHeight2,
  getEstimatedTotalWidth: getEstimatedTotalWidth2,
  getColumnOffset,
  getRowOffset,
  getRowPosition,
  getRowStartIndexForOffset,
  getRowStopIndexForStartIndex,
  initCache,
  injectToInstance,
  validateProps
}) => {
  return defineComponent({
    name: name != null ? name : "ElVirtualList",
    props: virtualizedGridProps,
    emits: [ITEM_RENDER_EVT, SCROLL_EVT],
    setup(props, { emit, expose, slots }) {
      const ns = useNamespace("vl");
      validateProps(props);
      const instance = getCurrentInstance();
      const cache2 = ref(initCache(props, instance));
      injectToInstance == null ? void 0 : injectToInstance(instance, cache2);
      const windowRef = ref();
      const hScrollbar = ref();
      const vScrollbar = ref();
      const innerRef = ref();
      const states = ref({
        isScrolling: false,
        scrollLeft: isNumber$1(props.initScrollLeft) ? props.initScrollLeft : 0,
        scrollTop: isNumber$1(props.initScrollTop) ? props.initScrollTop : 0,
        updateRequested: false,
        xAxisScrollDir: FORWARD,
        yAxisScrollDir: FORWARD
      });
      const getItemStyleCache = useCache();
      const parsedHeight = computed(
        () => Number.parseInt(`${props.height}`, 10)
      );
      const parsedWidth = computed(() => Number.parseInt(`${props.width}`, 10));
      const columnsToRender = computed(() => {
        const { totalColumn, totalRow, columnCache } = props;
        const { isScrolling, xAxisScrollDir, scrollLeft } = unref(states);
        if (totalColumn === 0 || totalRow === 0) {
          return [0, 0, 0, 0];
        }
        const startIndex = getColumnStartIndexForOffset(
          props,
          scrollLeft,
          unref(cache2)
        );
        const stopIndex = getColumnStopIndexForStartIndex(
          props,
          startIndex,
          scrollLeft,
          unref(cache2)
        );
        const cacheBackward = !isScrolling || xAxisScrollDir === BACKWARD ? Math.max(1, columnCache) : 1;
        const cacheForward = !isScrolling || xAxisScrollDir === FORWARD ? Math.max(1, columnCache) : 1;
        return [
          Math.max(0, startIndex - cacheBackward),
          Math.max(0, Math.min(totalColumn - 1, stopIndex + cacheForward)),
          startIndex,
          stopIndex
        ];
      });
      const rowsToRender = computed(() => {
        const { totalColumn, totalRow, rowCache } = props;
        const { isScrolling, yAxisScrollDir, scrollTop } = unref(states);
        if (totalColumn === 0 || totalRow === 0) {
          return [0, 0, 0, 0];
        }
        const startIndex = getRowStartIndexForOffset(
          props,
          scrollTop,
          unref(cache2)
        );
        const stopIndex = getRowStopIndexForStartIndex(
          props,
          startIndex,
          scrollTop,
          unref(cache2)
        );
        const cacheBackward = !isScrolling || yAxisScrollDir === BACKWARD ? Math.max(1, rowCache) : 1;
        const cacheForward = !isScrolling || yAxisScrollDir === FORWARD ? Math.max(1, rowCache) : 1;
        return [
          Math.max(0, startIndex - cacheBackward),
          Math.max(0, Math.min(totalRow - 1, stopIndex + cacheForward)),
          startIndex,
          stopIndex
        ];
      });
      const estimatedTotalHeight = computed(
        () => getEstimatedTotalHeight2(props, unref(cache2))
      );
      const estimatedTotalWidth = computed(
        () => getEstimatedTotalWidth2(props, unref(cache2))
      );
      const windowStyle = computed(() => {
        var _a;
        return [
          {
            position: "relative",
            overflow: "hidden",
            WebkitOverflowScrolling: "touch",
            willChange: "transform"
          },
          {
            direction: props.direction,
            height: isNumber$1(props.height) ? `${props.height}px` : props.height,
            width: isNumber$1(props.width) ? `${props.width}px` : props.width
          },
          (_a = props.style) != null ? _a : {}
        ];
      });
      const innerStyle = computed(() => {
        const width = `${unref(estimatedTotalWidth)}px`;
        const height = `${unref(estimatedTotalHeight)}px`;
        return {
          height,
          pointerEvents: unref(states).isScrolling ? "none" : void 0,
          width,
          margin: 0,
          boxSizing: "border-box"
        };
      });
      const emitEvents = () => {
        const { totalColumn, totalRow } = props;
        if (totalColumn > 0 && totalRow > 0) {
          const [
            columnCacheStart,
            columnCacheEnd,
            columnVisibleStart,
            columnVisibleEnd
          ] = unref(columnsToRender);
          const [rowCacheStart, rowCacheEnd, rowVisibleStart, rowVisibleEnd] = unref(rowsToRender);
          emit(ITEM_RENDER_EVT, {
            columnCacheStart,
            columnCacheEnd,
            rowCacheStart,
            rowCacheEnd,
            columnVisibleStart,
            columnVisibleEnd,
            rowVisibleStart,
            rowVisibleEnd
          });
        }
        const {
          scrollLeft,
          scrollTop,
          updateRequested,
          xAxisScrollDir,
          yAxisScrollDir
        } = unref(states);
        emit(SCROLL_EVT, {
          xAxisScrollDir,
          scrollLeft,
          yAxisScrollDir,
          scrollTop,
          updateRequested
        });
      };
      const onScroll = (e12) => {
        const {
          clientHeight,
          clientWidth,
          scrollHeight,
          scrollLeft,
          scrollTop,
          scrollWidth
        } = e12.currentTarget;
        const _states = unref(states);
        if (_states.scrollTop === scrollTop && _states.scrollLeft === scrollLeft) {
          return;
        }
        let _scrollLeft = scrollLeft;
        if (isRTL(props.direction)) {
          switch (getRTLOffsetType()) {
            case RTL_OFFSET_NAG:
              _scrollLeft = -scrollLeft;
              break;
            case RTL_OFFSET_POS_DESC:
              _scrollLeft = scrollWidth - clientWidth - scrollLeft;
              break;
          }
        }
        states.value = {
          ..._states,
          isScrolling: true,
          scrollLeft: _scrollLeft,
          scrollTop: Math.max(
            0,
            Math.min(scrollTop, scrollHeight - clientHeight)
          ),
          updateRequested: true,
          xAxisScrollDir: getScrollDir(_states.scrollLeft, _scrollLeft),
          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop)
        };
        nextTick(() => resetIsScrolling());
        onUpdated();
        emitEvents();
      };
      const onVerticalScroll = (distance, totalSteps) => {
        const height = unref(parsedHeight);
        const offset = (estimatedTotalHeight.value - height) / totalSteps * distance;
        scrollTo({
          scrollTop: Math.min(estimatedTotalHeight.value - height, offset)
        });
      };
      const onHorizontalScroll = (distance, totalSteps) => {
        const width = unref(parsedWidth);
        const offset = (estimatedTotalWidth.value - width) / totalSteps * distance;
        scrollTo({
          scrollLeft: Math.min(estimatedTotalWidth.value - width, offset)
        });
      };
      const { onWheel } = useGridWheel(
        {
          atXStartEdge: computed(() => states.value.scrollLeft <= 0),
          atXEndEdge: computed(
            () => states.value.scrollLeft >= estimatedTotalWidth.value - unref(parsedWidth)
          ),
          atYStartEdge: computed(() => states.value.scrollTop <= 0),
          atYEndEdge: computed(
            () => states.value.scrollTop >= estimatedTotalHeight.value - unref(parsedHeight)
          )
        },
        (x2, y2) => {
          var _a, _b, _c, _d;
          (_b = (_a = hScrollbar.value) == null ? void 0 : _a.onMouseUp) == null ? void 0 : _b.call(_a);
          (_d = (_c = vScrollbar.value) == null ? void 0 : _c.onMouseUp) == null ? void 0 : _d.call(_c);
          const width = unref(parsedWidth);
          const height = unref(parsedHeight);
          scrollTo({
            scrollLeft: Math.min(
              states.value.scrollLeft + x2,
              estimatedTotalWidth.value - width
            ),
            scrollTop: Math.min(
              states.value.scrollTop + y2,
              estimatedTotalHeight.value - height
            )
          });
        }
      );
      useEventListener(windowRef, "wheel", onWheel, {
        passive: false
      });
      const scrollTo = ({
        scrollLeft = states.value.scrollLeft,
        scrollTop = states.value.scrollTop
      }) => {
        scrollLeft = Math.max(scrollLeft, 0);
        scrollTop = Math.max(scrollTop, 0);
        const _states = unref(states);
        if (scrollTop === _states.scrollTop && scrollLeft === _states.scrollLeft) {
          return;
        }
        states.value = {
          ..._states,
          xAxisScrollDir: getScrollDir(_states.scrollLeft, scrollLeft),
          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop),
          scrollLeft,
          scrollTop,
          updateRequested: true
        };
        nextTick(() => resetIsScrolling());
        onUpdated();
        emitEvents();
      };
      const { touchStartX, touchStartY, handleTouchStart, handleTouchMove } = useGridTouch(
        windowRef,
        states,
        scrollTo,
        estimatedTotalWidth,
        estimatedTotalHeight,
        parsedWidth,
        parsedHeight
      );
      const scrollToItem = (rowIndex = 0, columnIdx = 0, alignment = AUTO_ALIGNMENT) => {
        const _states = unref(states);
        columnIdx = Math.max(0, Math.min(columnIdx, props.totalColumn - 1));
        rowIndex = Math.max(0, Math.min(rowIndex, props.totalRow - 1));
        const scrollBarWidth = getScrollBarWidth(ns.namespace.value);
        const _cache = unref(cache2);
        const estimatedHeight = getEstimatedTotalHeight2(props, _cache);
        const estimatedWidth = getEstimatedTotalWidth2(props, _cache);
        scrollTo({
          scrollLeft: getColumnOffset(
            props,
            columnIdx,
            alignment,
            _states.scrollLeft,
            _cache,
            estimatedWidth > props.width ? scrollBarWidth : 0
          ),
          scrollTop: getRowOffset(
            props,
            rowIndex,
            alignment,
            _states.scrollTop,
            _cache,
            estimatedHeight > props.height ? scrollBarWidth : 0
          )
        });
      };
      const getItemStyle = (rowIndex, columnIndex) => {
        const { columnWidth, direction: direction2, rowHeight } = props;
        const itemStyleCache = getItemStyleCache.value(
          clearCache && columnWidth,
          clearCache && rowHeight,
          clearCache && direction2
        );
        const key = `${rowIndex},${columnIndex}`;
        if (hasOwn(itemStyleCache, key)) {
          return itemStyleCache[key];
        } else {
          const [, left] = getColumnPosition(props, columnIndex, unref(cache2));
          const _cache = unref(cache2);
          const rtl = isRTL(direction2);
          const [height, top] = getRowPosition(props, rowIndex, _cache);
          const [width] = getColumnPosition(props, columnIndex, _cache);
          itemStyleCache[key] = {
            position: "absolute",
            left: rtl ? void 0 : `${left}px`,
            right: rtl ? `${left}px` : void 0,
            top: `${top}px`,
            height: `${height}px`,
            width: `${width}px`
          };
          return itemStyleCache[key];
        }
      };
      const resetIsScrolling = () => {
        states.value.isScrolling = false;
        nextTick(() => {
          getItemStyleCache.value(-1, null, null);
        });
      };
      const onUpdated = () => {
        const { direction: direction2 } = props;
        const { scrollLeft, scrollTop, updateRequested } = unref(states);
        const windowElement = unref(windowRef);
        if (updateRequested && windowElement) {
          if (direction2 === RTL) {
            switch (getRTLOffsetType()) {
              case RTL_OFFSET_NAG: {
                windowElement.scrollLeft = -scrollLeft;
                break;
              }
              case RTL_OFFSET_POS_ASC: {
                windowElement.scrollLeft = scrollLeft;
                break;
              }
              default: {
                const { clientWidth, scrollWidth } = windowElement;
                windowElement.scrollLeft = scrollWidth - clientWidth - scrollLeft;
                break;
              }
            }
          } else {
            windowElement.scrollLeft = Math.max(0, scrollLeft);
          }
          windowElement.scrollTop = Math.max(0, scrollTop);
        }
      };
      const { resetAfterColumnIndex, resetAfterRowIndex, resetAfter } = instance.proxy;
      expose({
        windowRef,
        innerRef,
        getItemStyleCache,
        touchStartX,
        touchStartY,
        handleTouchStart,
        handleTouchMove,
        scrollTo,
        scrollToItem,
        states,
        resetAfterColumnIndex,
        resetAfterRowIndex,
        resetAfter
      });
      const renderScrollbars = () => {
        const {
          scrollbarAlwaysOn,
          scrollbarStartGap,
          scrollbarEndGap,
          totalColumn,
          totalRow
        } = props;
        const width = unref(parsedWidth);
        const height = unref(parsedHeight);
        const estimatedWidth = unref(estimatedTotalWidth);
        const estimatedHeight = unref(estimatedTotalHeight);
        const { scrollLeft, scrollTop } = unref(states);
        const horizontalScrollbar = h(ScrollBar, {
          ref: hScrollbar,
          alwaysOn: scrollbarAlwaysOn,
          startGap: scrollbarStartGap,
          endGap: scrollbarEndGap,
          class: ns.e("horizontal"),
          clientSize: width,
          layout: "horizontal",
          onScroll: onHorizontalScroll,
          ratio: width * 100 / estimatedWidth,
          scrollFrom: scrollLeft / (estimatedWidth - width),
          total: totalRow,
          visible: true
        });
        const verticalScrollbar = h(ScrollBar, {
          ref: vScrollbar,
          alwaysOn: scrollbarAlwaysOn,
          startGap: scrollbarStartGap,
          endGap: scrollbarEndGap,
          class: ns.e("vertical"),
          clientSize: height,
          layout: "vertical",
          onScroll: onVerticalScroll,
          ratio: height * 100 / estimatedHeight,
          scrollFrom: scrollTop / (estimatedHeight - height),
          total: totalColumn,
          visible: true
        });
        return {
          horizontalScrollbar,
          verticalScrollbar
        };
      };
      const renderItems = () => {
        var _a;
        const [columnStart, columnEnd] = unref(columnsToRender);
        const [rowStart, rowEnd] = unref(rowsToRender);
        const { data, totalColumn, totalRow, useIsScrolling, itemKey } = props;
        const children = [];
        if (totalRow > 0 && totalColumn > 0) {
          for (let row = rowStart; row <= rowEnd; row++) {
            for (let column = columnStart; column <= columnEnd; column++) {
              const key = itemKey({ columnIndex: column, data, rowIndex: row });
              children.push(
                h(
                  Fragment,
                  { key },
                  (_a = slots.default) == null ? void 0 : _a.call(slots, {
                    columnIndex: column,
                    data,
                    isScrolling: useIsScrolling ? unref(states).isScrolling : void 0,
                    style: getItemStyle(row, column),
                    rowIndex: row
                  })
                )
              );
            }
          }
        }
        return children;
      };
      const renderInner = () => {
        const Inner = resolveDynamicComponent(props.innerElement);
        const children = renderItems();
        return [
          h(
            Inner,
            mergeProps(props.innerProps, {
              style: unref(innerStyle),
              ref: innerRef
            }),
            !isString(Inner) ? {
              default: () => children
            } : children
          )
        ];
      };
      const renderWindow = () => {
        const Container = resolveDynamicComponent(
          props.containerElement
        );
        const { horizontalScrollbar, verticalScrollbar } = renderScrollbars();
        const Inner = renderInner();
        return h(
          "div",
          {
            key: 0,
            class: ns.e("wrapper"),
            role: props.role
          },
          [
            h(
              Container,
              {
                class: props.className,
                style: unref(windowStyle),
                onScroll,
                ref: windowRef
              },
              !isString(Container) ? { default: () => Inner } : Inner
            ),
            horizontalScrollbar,
            verticalScrollbar
          ]
        );
      };
      return renderWindow;
    }
  });
};
const { max, min, floor } = Math;
const ACCESS_SIZER_KEY_MAP = {
  column: "columnWidth",
  row: "rowHeight"
};
const ACCESS_LAST_VISITED_KEY_MAP = {
  column: "lastVisitedColumnIndex",
  row: "lastVisitedRowIndex"
};
const getItemFromCache = (props, index, gridCache, type) => {
  const [cachedItems, sizer, lastVisited] = [
    gridCache[type],
    props[ACCESS_SIZER_KEY_MAP[type]],
    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]]
  ];
  if (index > lastVisited) {
    let offset = 0;
    if (lastVisited >= 0) {
      const item = cachedItems[lastVisited];
      offset = item.offset + item.size;
    }
    for (let i8 = lastVisited + 1; i8 <= index; i8++) {
      const size = sizer(i8);
      cachedItems[i8] = {
        offset,
        size
      };
      offset += size;
    }
    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]] = index;
  }
  return cachedItems[index];
};
const bs = (props, gridCache, low, high, offset, type) => {
  while (low <= high) {
    const mid = low + floor((high - low) / 2);
    const currentOffset = getItemFromCache(props, mid, gridCache, type).offset;
    if (currentOffset === offset) {
      return mid;
    } else if (currentOffset < offset) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }
  return max(0, low - 1);
};
const es = (props, gridCache, idx, offset, type) => {
  const total2 = type === "column" ? props.totalColumn : props.totalRow;
  let exponent = 1;
  while (idx < total2 && getItemFromCache(props, idx, gridCache, type).offset < offset) {
    idx += exponent;
    exponent *= 2;
  }
  return bs(props, gridCache, floor(idx / 2), min(idx, total2 - 1), offset, type);
};
const findItem = (props, gridCache, offset, type) => {
  const [cache2, lastVisitedIndex] = [
    gridCache[type],
    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]]
  ];
  const lastVisitedItemOffset = lastVisitedIndex > 0 ? cache2[lastVisitedIndex].offset : 0;
  if (lastVisitedItemOffset >= offset) {
    return bs(props, gridCache, 0, lastVisitedIndex, offset, type);
  }
  return es(props, gridCache, max(0, lastVisitedIndex), offset, type);
};
const getEstimatedTotalHeight = ({ totalRow }, { estimatedRowHeight, lastVisitedRowIndex, row }) => {
  let sizeOfVisitedRows = 0;
  if (lastVisitedRowIndex >= totalRow) {
    lastVisitedRowIndex = totalRow - 1;
  }
  if (lastVisitedRowIndex >= 0) {
    const item = row[lastVisitedRowIndex];
    sizeOfVisitedRows = item.offset + item.size;
  }
  const unvisitedItems = totalRow - lastVisitedRowIndex - 1;
  const sizeOfUnvisitedItems = unvisitedItems * estimatedRowHeight;
  return sizeOfVisitedRows + sizeOfUnvisitedItems;
};
const getEstimatedTotalWidth = ({ totalColumn }, { column, estimatedColumnWidth, lastVisitedColumnIndex }) => {
  let sizeOfVisitedColumns = 0;
  if (lastVisitedColumnIndex > totalColumn) {
    lastVisitedColumnIndex = totalColumn - 1;
  }
  if (lastVisitedColumnIndex >= 0) {
    const item = column[lastVisitedColumnIndex];
    sizeOfVisitedColumns = item.offset + item.size;
  }
  const unvisitedItems = totalColumn - lastVisitedColumnIndex - 1;
  const sizeOfUnvisitedItems = unvisitedItems * estimatedColumnWidth;
  return sizeOfVisitedColumns + sizeOfUnvisitedItems;
};
const ACCESS_ESTIMATED_SIZE_KEY_MAP = {
  column: getEstimatedTotalWidth,
  row: getEstimatedTotalHeight
};
const getOffset = (props, index, alignment, scrollOffset, cache2, type, scrollBarWidth) => {
  const [size, estimatedSizeAssociates] = [
    type === "row" ? props.height : props.width,
    ACCESS_ESTIMATED_SIZE_KEY_MAP[type]
  ];
  const item = getItemFromCache(props, index, cache2, type);
  const estimatedSize = estimatedSizeAssociates(props, cache2);
  const maxOffset = max(0, min(estimatedSize - size, item.offset));
  const minOffset = max(0, item.offset - size + scrollBarWidth + item.size);
  if (alignment === SMART_ALIGNMENT) {
    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {
      alignment = AUTO_ALIGNMENT;
    } else {
      alignment = CENTERED_ALIGNMENT;
    }
  }
  switch (alignment) {
    case START_ALIGNMENT: {
      return maxOffset;
    }
    case END_ALIGNMENT: {
      return minOffset;
    }
    case CENTERED_ALIGNMENT: {
      return Math.round(minOffset + (maxOffset - minOffset) / 2);
    }
    case AUTO_ALIGNMENT:
    default: {
      if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {
        return scrollOffset;
      } else if (minOffset > maxOffset) {
        return minOffset;
      } else if (scrollOffset < minOffset) {
        return minOffset;
      } else {
        return maxOffset;
      }
    }
  }
};
const DynamicSizeGrid = createGrid({
  name: "ElDynamicSizeGrid",
  getColumnPosition: (props, idx, cache2) => {
    const item = getItemFromCache(props, idx, cache2, "column");
    return [item.size, item.offset];
  },
  getRowPosition: (props, idx, cache2) => {
    const item = getItemFromCache(props, idx, cache2, "row");
    return [item.size, item.offset];
  },
  getColumnOffset: (props, columnIndex, alignment, scrollLeft, cache2, scrollBarWidth) => getOffset(
    props,
    columnIndex,
    alignment,
    scrollLeft,
    cache2,
    "column",
    scrollBarWidth
  ),
  getRowOffset: (props, rowIndex, alignment, scrollTop, cache2, scrollBarWidth) => getOffset(
    props,
    rowIndex,
    alignment,
    scrollTop,
    cache2,
    "row",
    scrollBarWidth
  ),
  getColumnStartIndexForOffset: (props, scrollLeft, cache2) => findItem(props, cache2, scrollLeft, "column"),
  getColumnStopIndexForStartIndex: (props, startIndex, scrollLeft, cache2) => {
    const item = getItemFromCache(props, startIndex, cache2, "column");
    const maxOffset = scrollLeft + props.width;
    let offset = item.offset + item.size;
    let stopIndex = startIndex;
    while (stopIndex < props.totalColumn - 1 && offset < maxOffset) {
      stopIndex++;
      offset += getItemFromCache(props, startIndex, cache2, "column").size;
    }
    return stopIndex;
  },
  getEstimatedTotalHeight,
  getEstimatedTotalWidth,
  getRowStartIndexForOffset: (props, scrollTop, cache2) => findItem(props, cache2, scrollTop, "row"),
  getRowStopIndexForStartIndex: (props, startIndex, scrollTop, cache2) => {
    const { totalRow, height } = props;
    const item = getItemFromCache(props, startIndex, cache2, "row");
    const maxOffset = scrollTop + height;
    let offset = item.size + item.offset;
    let stopIndex = startIndex;
    while (stopIndex < totalRow - 1 && offset < maxOffset) {
      stopIndex++;
      offset += getItemFromCache(props, stopIndex, cache2, "row").size;
    }
    return stopIndex;
  },
  injectToInstance: (instance, cache2) => {
    const resetAfter = ({ columnIndex, rowIndex }, forceUpdate) => {
      var _a, _b;
      forceUpdate = isUndefined$1(forceUpdate) ? true : forceUpdate;
      if (isNumber$1(columnIndex)) {
        cache2.value.lastVisitedColumnIndex = Math.min(
          cache2.value.lastVisitedColumnIndex,
          columnIndex - 1
        );
      }
      if (isNumber$1(rowIndex)) {
        cache2.value.lastVisitedRowIndex = Math.min(
          cache2.value.lastVisitedRowIndex,
          rowIndex - 1
        );
      }
      (_a = instance.exposed) == null ? void 0 : _a.getItemStyleCache.value(-1, null, null);
      if (forceUpdate)
        (_b = instance.proxy) == null ? void 0 : _b.$forceUpdate();
    };
    const resetAfterColumnIndex = (columnIndex, forceUpdate) => {
      resetAfter(
        {
          columnIndex
        },
        forceUpdate
      );
    };
    const resetAfterRowIndex = (rowIndex, forceUpdate) => {
      resetAfter(
        {
          rowIndex
        },
        forceUpdate
      );
    };
    Object.assign(instance.proxy, {
      resetAfterColumnIndex,
      resetAfterRowIndex,
      resetAfter
    });
  },
  initCache: ({
    estimatedColumnWidth = DEFAULT_DYNAMIC_LIST_ITEM_SIZE,
    estimatedRowHeight = DEFAULT_DYNAMIC_LIST_ITEM_SIZE
  }) => {
    const cache2 = {
      column: {},
      estimatedColumnWidth,
      estimatedRowHeight,
      lastVisitedColumnIndex: -1,
      lastVisitedRowIndex: -1,
      row: {}
    };
    return cache2;
  },
  clearCache: false,
  validateProps: ({ columnWidth, rowHeight }) => {
  }
});
const FixedSizeGrid = createGrid({
  name: "ElFixedSizeGrid",
  getColumnPosition: ({ columnWidth }, index) => [
    columnWidth,
    index * columnWidth
  ],
  getRowPosition: ({ rowHeight }, index) => [
    rowHeight,
    index * rowHeight
  ],
  getEstimatedTotalHeight: ({ totalRow, rowHeight }) => rowHeight * totalRow,
  getEstimatedTotalWidth: ({ totalColumn, columnWidth }) => columnWidth * totalColumn,
  getColumnOffset: ({ totalColumn, columnWidth, width }, columnIndex, alignment, scrollLeft, _, scrollBarWidth) => {
    width = Number(width);
    const lastColumnOffset = Math.max(
      0,
      totalColumn * columnWidth - width
    );
    const maxOffset = Math.min(
      lastColumnOffset,
      columnIndex * columnWidth
    );
    const minOffset = Math.max(
      0,
      columnIndex * columnWidth - width + scrollBarWidth + columnWidth
    );
    if (alignment === "smart") {
      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {
        alignment = AUTO_ALIGNMENT;
      } else {
        alignment = CENTERED_ALIGNMENT;
      }
    }
    switch (alignment) {
      case START_ALIGNMENT:
        return maxOffset;
      case END_ALIGNMENT:
        return minOffset;
      case CENTERED_ALIGNMENT: {
        const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);
        if (middleOffset < Math.ceil(width / 2)) {
          return 0;
        } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {
          return lastColumnOffset;
        } else {
          return middleOffset;
        }
      }
      case AUTO_ALIGNMENT:
      default:
        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {
          return scrollLeft;
        } else if (minOffset > maxOffset) {
          return minOffset;
        } else if (scrollLeft < minOffset) {
          return minOffset;
        } else {
          return maxOffset;
        }
    }
  },
  getRowOffset: ({ rowHeight, height, totalRow }, rowIndex, align, scrollTop, _, scrollBarWidth) => {
    height = Number(height);
    const lastRowOffset = Math.max(0, totalRow * rowHeight - height);
    const maxOffset = Math.min(lastRowOffset, rowIndex * rowHeight);
    const minOffset = Math.max(
      0,
      rowIndex * rowHeight - height + scrollBarWidth + rowHeight
    );
    if (align === SMART_ALIGNMENT) {
      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {
        align = AUTO_ALIGNMENT;
      } else {
        align = CENTERED_ALIGNMENT;
      }
    }
    switch (align) {
      case START_ALIGNMENT:
        return maxOffset;
      case END_ALIGNMENT:
        return minOffset;
      case CENTERED_ALIGNMENT: {
        const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);
        if (middleOffset < Math.ceil(height / 2)) {
          return 0;
        } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {
          return lastRowOffset;
        } else {
          return middleOffset;
        }
      }
      case AUTO_ALIGNMENT:
      default:
        if (scrollTop >= minOffset && scrollTop <= maxOffset) {
          return scrollTop;
        } else if (minOffset > maxOffset) {
          return minOffset;
        } else if (scrollTop < minOffset) {
          return minOffset;
        } else {
          return maxOffset;
        }
    }
  },
  getColumnStartIndexForOffset: ({ columnWidth, totalColumn }, scrollLeft) => Math.max(
    0,
    Math.min(
      totalColumn - 1,
      Math.floor(scrollLeft / columnWidth)
    )
  ),
  getColumnStopIndexForStartIndex: ({ columnWidth, totalColumn, width }, startIndex, scrollLeft) => {
    const left = startIndex * columnWidth;
    const visibleColumnsCount = Math.ceil(
      (width + scrollLeft - left) / columnWidth
    );
    return Math.max(
      0,
      Math.min(totalColumn - 1, startIndex + visibleColumnsCount - 1)
    );
  },
  getRowStartIndexForOffset: ({ rowHeight, totalRow }, scrollTop) => Math.max(
    0,
    Math.min(totalRow - 1, Math.floor(scrollTop / rowHeight))
  ),
  getRowStopIndexForStartIndex: ({ rowHeight, totalRow, height }, startIndex, scrollTop) => {
    const top = startIndex * rowHeight;
    const numVisibleRows = Math.ceil(
      (height + scrollTop - top) / rowHeight
    );
    return Math.max(
      0,
      Math.min(
        totalRow - 1,
        startIndex + numVisibleRows - 1
      )
    );
  },
  initCache: () => void 0,
  clearCache: true,
  validateProps: ({ columnWidth, rowHeight }) => {
  }
});
const COMPONENT_NAME$2 = "ElTableV2Grid";
const useTableGrid = (props) => {
  const headerRef = ref();
  const bodyRef = ref();
  const scrollLeft = ref(0);
  const totalHeight = computed(() => {
    const {
      data,
      rowHeight,
      estimatedRowHeight
    } = props;
    if (estimatedRowHeight) {
      return;
    }
    return data.length * rowHeight;
  });
  const fixedRowHeight = computed(() => {
    const {
      fixedData,
      rowHeight
    } = props;
    return ((fixedData == null ? void 0 : fixedData.length) || 0) * rowHeight;
  });
  const headerHeight = computed(() => sum(props.headerHeight));
  const gridHeight = computed(() => {
    const {
      height
    } = props;
    return Math.max(0, height - unref(headerHeight) - unref(fixedRowHeight));
  });
  const hasHeader = computed(() => {
    return unref(headerHeight) + unref(fixedRowHeight) > 0;
  });
  const itemKey = ({
    data,
    rowIndex
  }) => data[rowIndex][props.rowKey];
  function onItemRendered({
    rowCacheStart,
    rowCacheEnd,
    rowVisibleStart,
    rowVisibleEnd
  }) {
    var _a;
    (_a = props.onRowsRendered) == null ? void 0 : _a.call(props, {
      rowCacheStart,
      rowCacheEnd,
      rowVisibleStart,
      rowVisibleEnd
    });
  }
  function resetAfterRowIndex(index, forceUpdate2) {
    var _a;
    (_a = bodyRef.value) == null ? void 0 : _a.resetAfterRowIndex(index, forceUpdate2);
  }
  function scrollTo(leftOrOptions, top) {
    const header$ = unref(headerRef);
    const body$ = unref(bodyRef);
    if (isObject(leftOrOptions)) {
      header$ == null ? void 0 : header$.scrollToLeft(leftOrOptions.scrollLeft);
      scrollLeft.value = leftOrOptions.scrollLeft;
      body$ == null ? void 0 : body$.scrollTo(leftOrOptions);
    } else {
      header$ == null ? void 0 : header$.scrollToLeft(leftOrOptions);
      scrollLeft.value = leftOrOptions;
      body$ == null ? void 0 : body$.scrollTo({
        scrollLeft: leftOrOptions,
        scrollTop: top
      });
    }
  }
  function scrollToTop(scrollTop) {
    var _a;
    (_a = unref(bodyRef)) == null ? void 0 : _a.scrollTo({
      scrollTop
    });
  }
  function scrollToRow(row, strategy) {
    const body = unref(bodyRef);
    if (!body)
      return;
    const prevScrollLeft = scrollLeft.value;
    body.scrollToItem(row, 0, strategy);
    if (prevScrollLeft) {
      scrollTo({
        scrollLeft: prevScrollLeft
      });
    }
  }
  function forceUpdate() {
    var _a, _b;
    (_a = unref(bodyRef)) == null ? void 0 : _a.$forceUpdate();
    (_b = unref(headerRef)) == null ? void 0 : _b.$forceUpdate();
  }
  watch(() => props.bodyWidth, () => {
    var _a;
    if (isNumber$1(props.estimatedRowHeight))
      (_a = bodyRef.value) == null ? void 0 : _a.resetAfter({
        columnIndex: 0
      }, false);
  });
  return {
    bodyRef,
    forceUpdate,
    fixedRowHeight,
    gridHeight,
    hasHeader,
    headerHeight,
    headerRef,
    totalHeight,
    itemKey,
    onItemRendered,
    resetAfterRowIndex,
    scrollTo,
    scrollToTop,
    scrollToRow,
    scrollLeft
  };
};
const TableGrid = defineComponent({
  name: COMPONENT_NAME$2,
  props: tableV2GridProps,
  setup(props, {
    slots,
    expose
  }) {
    const {
      ns
    } = inject(TableV2InjectionKey);
    const {
      bodyRef,
      fixedRowHeight,
      gridHeight,
      hasHeader,
      headerRef,
      headerHeight,
      totalHeight,
      forceUpdate,
      itemKey,
      onItemRendered,
      resetAfterRowIndex,
      scrollTo,
      scrollToTop,
      scrollToRow,
      scrollLeft
    } = useTableGrid(props);
    provide(TABLE_V2_GRID_INJECTION_KEY, scrollLeft);
    expose({
      forceUpdate,
      totalHeight,
      scrollTo,
      scrollToTop,
      scrollToRow,
      resetAfterRowIndex
    });
    const getColumnWidth = () => props.bodyWidth;
    return () => {
      const {
        cache: cache2,
        columns: columns2,
        data,
        fixedData,
        useIsScrolling,
        scrollbarAlwaysOn,
        scrollbarEndGap,
        scrollbarStartGap,
        style,
        rowHeight,
        bodyWidth,
        estimatedRowHeight,
        headerWidth,
        height,
        width,
        getRowHeight,
        onScroll
      } = props;
      const isDynamicRowEnabled = isNumber$1(estimatedRowHeight);
      const Grid = isDynamicRowEnabled ? DynamicSizeGrid : FixedSizeGrid;
      const _headerHeight = unref(headerHeight);
      return createVNode("div", {
        "role": "table",
        "class": [ns.e("table"), props.class],
        "style": style
      }, [createVNode(Grid, {
        "ref": bodyRef,
        "data": data,
        "useIsScrolling": useIsScrolling,
        "itemKey": itemKey,
        "columnCache": 0,
        "columnWidth": isDynamicRowEnabled ? getColumnWidth : bodyWidth,
        "totalColumn": 1,
        "totalRow": data.length,
        "rowCache": cache2,
        "rowHeight": isDynamicRowEnabled ? getRowHeight : rowHeight,
        "width": width,
        "height": unref(gridHeight),
        "class": ns.e("body"),
        "role": "rowgroup",
        "scrollbarStartGap": scrollbarStartGap,
        "scrollbarEndGap": scrollbarEndGap,
        "scrollbarAlwaysOn": scrollbarAlwaysOn,
        "onScroll": onScroll,
        "onItemRendered": onItemRendered,
        "perfMode": false
      }, {
        default: (params) => {
          var _a;
          const rowData = data[params.rowIndex];
          return (_a = slots.row) == null ? void 0 : _a.call(slots, {
            ...params,
            columns: columns2,
            rowData
          });
        }
      }), unref(hasHeader) && createVNode(Header$1, {
        "ref": headerRef,
        "class": ns.e("header-wrapper"),
        "columns": columns2,
        "headerData": data,
        "headerHeight": props.headerHeight,
        "fixedHeaderData": fixedData,
        "rowWidth": headerWidth,
        "rowHeight": rowHeight,
        "width": width,
        "height": Math.min(_headerHeight + unref(fixedRowHeight), height)
      }, {
        dynamic: slots.header,
        fixed: slots.row
      })]);
    };
  }
});
var Table = TableGrid;
function _isSlot$5(s11) {
  return typeof s11 === "function" || Object.prototype.toString.call(s11) === "[object Object]" && !isVNode(s11);
}
const MainTable = (props, {
  slots
}) => {
  const {
    mainTableRef,
    ...rest
  } = props;
  return createVNode(Table, mergeProps({
    "ref": mainTableRef
  }, rest), _isSlot$5(slots) ? slots : {
    default: () => [slots]
  });
};
var MainTable$1 = MainTable;
function _isSlot$4(s11) {
  return typeof s11 === "function" || Object.prototype.toString.call(s11) === "[object Object]" && !isVNode(s11);
}
const LeftTable = (props, {
  slots
}) => {
  if (!props.columns.length)
    return;
  const {
    leftTableRef,
    ...rest
  } = props;
  return createVNode(Table, mergeProps({
    "ref": leftTableRef
  }, rest), _isSlot$4(slots) ? slots : {
    default: () => [slots]
  });
};
var LeftTable$1 = LeftTable;
function _isSlot$3(s11) {
  return typeof s11 === "function" || Object.prototype.toString.call(s11) === "[object Object]" && !isVNode(s11);
}
const RightTable = (props, {
  slots
}) => {
  if (!props.columns.length)
    return;
  const {
    rightTableRef,
    ...rest
  } = props;
  return createVNode(Table, mergeProps({
    "ref": rightTableRef
  }, rest), _isSlot$3(slots) ? slots : {
    default: () => [slots]
  });
};
var RightTable$1 = RightTable;
const useTableRow = (props) => {
  const {
    isScrolling
  } = inject(TableV2InjectionKey);
  const measured = ref(false);
  const rowRef = ref();
  const measurable = computed(() => {
    return isNumber$1(props.estimatedRowHeight) && props.rowIndex >= 0;
  });
  const eventHandlers = computed(() => {
    const {
      rowData,
      rowIndex,
      rowKey: rowKey2,
      onRowHover
    } = props;
    const handlers = props.rowEventHandlers || {};
    const eventHandlers2 = {};
    Object.entries(handlers).forEach(([eventName, handler]) => {
      if (isFunction(handler)) {
        eventHandlers2[eventName] = (event) => {
          handler({
            event,
            rowData,
            rowIndex,
            rowKey: rowKey2
          });
        };
      }
    });
    if (onRowHover) {
      [{
        name: "onMouseleave",
        hovered: false
      }, {
        name: "onMouseenter",
        hovered: true
      }].forEach(({
        name,
        hovered
      }) => {
        const existedHandler = eventHandlers2[name];
        eventHandlers2[name] = (event) => {
          onRowHover({
            event,
            hovered,
            rowData,
            rowIndex,
            rowKey: rowKey2
          });
          existedHandler == null ? void 0 : existedHandler(event);
        };
      });
    }
    return eventHandlers2;
  });
  const onExpand = (expanded) => {
    const {
      onRowExpand,
      rowData,
      rowIndex,
      rowKey: rowKey2
    } = props;
    onRowExpand == null ? void 0 : onRowExpand({
      expanded,
      rowData,
      rowIndex,
      rowKey: rowKey2
    });
  };
  return {
    isScrolling,
    measurable,
    measured,
    rowRef,
    eventHandlers,
    onExpand
  };
};
const COMPONENT_NAME$1 = "ElTableV2TableRow";
const TableV2Row = defineComponent({
  name: COMPONENT_NAME$1,
  props: tableV2RowProps,
  setup(props, {
    expose,
    slots,
    attrs
  }) {
    const {
      eventHandlers,
      isScrolling,
      measurable,
      measured,
      rowRef,
      onExpand
    } = useTableRow(props);
    expose({
      onExpand
    });
    return () => {
      const {
        columns: columns2,
        columnsStyles,
        expandColumnKey: expandColumnKey2,
        depth,
        rowData,
        rowIndex,
        style
      } = props;
      let ColumnCells = columns2.map((column, columnIndex) => {
        const expandable = isArray(rowData.children) && rowData.children.length > 0 && column.key === expandColumnKey2;
        return slots.cell({
          column,
          columns: columns2,
          columnIndex,
          depth,
          style: columnsStyles[column.key],
          rowData,
          rowIndex,
          isScrolling: unref(isScrolling),
          expandIconProps: expandable ? {
            rowData,
            rowIndex,
            onExpand
          } : void 0
        });
      });
      if (slots.row) {
        ColumnCells = slots.row({
          cells: ColumnCells.map((node) => {
            if (isArray(node) && node.length === 1) {
              return node[0];
            }
            return node;
          }),
          style,
          columns: columns2,
          depth,
          rowData,
          rowIndex,
          isScrolling: unref(isScrolling)
        });
      }
      if (unref(measurable)) {
        const {
          height,
          ...exceptHeightStyle
        } = style || {};
        const _measured = unref(measured);
        return createVNode("div", mergeProps({
          "ref": rowRef,
          "class": props.class,
          "style": _measured ? style : exceptHeightStyle,
          "role": "row"
        }, attrs, unref(eventHandlers)), [ColumnCells]);
      }
      return createVNode("div", mergeProps(attrs, {
        "ref": rowRef,
        "class": props.class,
        "style": style,
        "role": "row"
      }, unref(eventHandlers)), [ColumnCells]);
    };
  }
});
var Row$1 = TableV2Row;
function _isSlot$2(s11) {
  return typeof s11 === "function" || Object.prototype.toString.call(s11) === "[object Object]" && !isVNode(s11);
}
const RowRenderer = (props, {
  slots
}) => {
  const {
    columns: columns2,
    columnsStyles,
    depthMap,
    expandColumnKey: expandColumnKey2,
    expandedRowKeys,
    estimatedRowHeight,
    hasFixedColumns,
    rowData,
    rowIndex,
    style,
    isScrolling,
    rowProps,
    rowClass,
    rowKey: rowKey2,
    rowEventHandlers,
    ns,
    onRowHovered,
    onRowExpanded
  } = props;
  const rowKls = tryCall(rowClass, {
    columns: columns2,
    rowData,
    rowIndex
  }, "");
  const additionalProps = tryCall(rowProps, {
    columns: columns2,
    rowData,
    rowIndex
  });
  const _rowKey = rowData[rowKey2];
  const depth = depthMap[_rowKey] || 0;
  const canExpand = Boolean(expandColumnKey2);
  const isFixedRow = rowIndex < 0;
  const kls = [ns.e("row"), rowKls, ns.is("expanded", canExpand && expandedRowKeys.includes(_rowKey)), ns.is("fixed", !depth && isFixedRow), ns.is("customized", Boolean(slots.row)), {
    [ns.e(`row-depth-${depth}`)]: canExpand && rowIndex >= 0
  }];
  const onRowHover = hasFixedColumns ? onRowHovered : void 0;
  const _rowProps = {
    ...additionalProps,
    columns: columns2,
    columnsStyles,
    class: kls,
    depth,
    expandColumnKey: expandColumnKey2,
    estimatedRowHeight: isFixedRow ? void 0 : estimatedRowHeight,
    isScrolling,
    rowIndex,
    rowData,
    rowKey: _rowKey,
    rowEventHandlers,
    style
  };
  const handlerMouseEnter = (e12) => {
    onRowHover == null ? void 0 : onRowHover({
      hovered: true,
      rowKey: _rowKey,
      event: e12,
      rowData,
      rowIndex
    });
  };
  const handlerMouseLeave = (e12) => {
    onRowHover == null ? void 0 : onRowHover({
      hovered: false,
      rowKey: _rowKey,
      event: e12,
      rowData,
      rowIndex
    });
  };
  return createVNode(Row$1, mergeProps(_rowProps, {
    "onRowExpand": onRowExpanded,
    "onMouseenter": handlerMouseEnter,
    "onMouseleave": handlerMouseLeave,
    "rowkey": _rowKey
  }), _isSlot$2(slots) ? slots : {
    default: () => [slots]
  });
};
var Row = RowRenderer;
const TableV2Cell = (props, {
  slots
}) => {
  var _a;
  const {
    cellData,
    style
  } = props;
  const displayText = ((_a = cellData == null ? void 0 : cellData.toString) == null ? void 0 : _a.call(cellData)) || "";
  const defaultSlot = renderSlot(slots, "default", props, () => [displayText]);
  return createVNode("div", {
    "class": props.class,
    "title": displayText,
    "style": style
  }, [defaultSlot]);
};
TableV2Cell.displayName = "ElTableV2Cell";
TableV2Cell.inheritAttrs = false;
var TableCell = TableV2Cell;
const ExpandIcon = (props) => {
  const {
    expanded,
    expandable,
    onExpand,
    style,
    size,
    ariaLabel
  } = props;
  const expandIconProps = {
    onClick: expandable ? () => onExpand(!expanded) : void 0,
    ariaLabel,
    ariaExpanded: expanded,
    class: props.class
  };
  return createVNode("button", mergeProps(expandIconProps, {
    "type": "button"
  }), [createVNode(ElIcon, {
    "size": size,
    "style": style
  }, {
    default: () => [createVNode(arrow_right_default, null, null)]
  })]);
};
ExpandIcon.inheritAttrs = false;
var ExpandIcon$1 = ExpandIcon;
const CellRenderer = ({
  columns: columns2,
  column,
  columnIndex,
  depth,
  expandIconProps,
  isScrolling,
  rowData,
  rowIndex,
  style,
  expandedRowKeys,
  ns,
  t: t6,
  cellProps: _cellProps,
  expandColumnKey: expandColumnKey2,
  indentSize,
  iconSize,
  rowKey: rowKey2
}, {
  slots
}) => {
  const cellStyle = enforceUnit(style);
  if (column.placeholderSign === placeholderSign) {
    return createVNode("div", {
      "class": ns.em("row-cell", "placeholder"),
      "style": cellStyle
    }, null);
  }
  const {
    cellRenderer,
    dataKey,
    dataGetter
  } = column;
  const cellData = isFunction(dataGetter) ? dataGetter({
    columns: columns2,
    column,
    columnIndex,
    rowData,
    rowIndex
  }) : get(rowData, dataKey != null ? dataKey : "");
  const extraCellProps = tryCall(_cellProps, {
    cellData,
    columns: columns2,
    column,
    columnIndex,
    rowIndex,
    rowData
  });
  const cellProps = {
    class: ns.e("cell-text"),
    columns: columns2,
    column,
    columnIndex,
    cellData,
    isScrolling,
    rowData,
    rowIndex
  };
  const columnCellRenderer = componentToSlot(cellRenderer);
  const Cell2 = columnCellRenderer ? columnCellRenderer(cellProps) : renderSlot(slots, "default", cellProps, () => [createVNode(TableCell, cellProps, null)]);
  const kls = [ns.e("row-cell"), column.class, column.align === Alignment.CENTER && ns.is("align-center"), column.align === Alignment.RIGHT && ns.is("align-right")];
  const expandable = rowIndex >= 0 && expandColumnKey2 && column.key === expandColumnKey2;
  const expanded = rowIndex >= 0 && expandedRowKeys.includes(rowData[rowKey2]);
  let IconOrPlaceholder;
  const iconStyle = `margin-inline-start: ${depth * indentSize}px;`;
  if (expandable) {
    if (isObject(expandIconProps)) {
      IconOrPlaceholder = createVNode(ExpandIcon$1, mergeProps(expandIconProps, {
        "class": [ns.e("expand-icon"), ns.is("expanded", expanded)],
        "size": iconSize,
        "expanded": expanded,
        "ariaLabel": t6(expanded ? "el.table.collapseRowLabel" : "el.table.expandRowLabel"),
        "style": iconStyle,
        "expandable": true
      }), null);
    } else {
      IconOrPlaceholder = createVNode("div", {
        "style": [iconStyle, `width: ${iconSize}px; height: ${iconSize}px;`].join(" ")
      }, null);
    }
  }
  return createVNode("div", mergeProps({
    "class": kls,
    "style": cellStyle
  }, extraCellProps, {
    "role": "cell"
  }), [IconOrPlaceholder, Cell2]);
};
CellRenderer.inheritAttrs = false;
var Cell = CellRenderer;
const tableV2HeaderRowProps = buildProps({
  class: String,
  columns,
  columnsStyles: {
    type: definePropType(Object),
    required: true
  },
  headerIndex: Number,
  style: { type: definePropType(Object) }
});
const TableV2HeaderRow = defineComponent({
  name: "ElTableV2HeaderRow",
  props: tableV2HeaderRowProps,
  setup(props, {
    slots
  }) {
    return () => {
      const {
        columns: columns2,
        columnsStyles,
        headerIndex,
        style
      } = props;
      let Cells = columns2.map((column, columnIndex) => {
        return slots.cell({
          columns: columns2,
          column,
          columnIndex,
          headerIndex,
          style: columnsStyles[column.key]
        });
      });
      if (slots.header) {
        Cells = slots.header({
          cells: Cells.map((node) => {
            if (isArray(node) && node.length === 1) {
              return node[0];
            }
            return node;
          }),
          columns: columns2,
          headerIndex
        });
      }
      return createVNode("div", {
        "class": props.class,
        "style": style,
        "role": "row"
      }, [Cells]);
    };
  }
});
var HeaderRow = TableV2HeaderRow;
function _isSlot$1(s11) {
  return typeof s11 === "function" || Object.prototype.toString.call(s11) === "[object Object]" && !isVNode(s11);
}
const HeaderRenderer = ({
  columns: columns2,
  columnsStyles,
  headerIndex,
  style,
  headerClass,
  headerProps,
  ns
}, {
  slots
}) => {
  const param = {
    columns: columns2,
    headerIndex
  };
  const kls = [ns.e("header-row"), tryCall(headerClass, param, ""), ns.is("customized", Boolean(slots.header))];
  const extraProps = {
    ...tryCall(headerProps, param),
    columnsStyles,
    class: kls,
    columns: columns2,
    headerIndex,
    style
  };
  return createVNode(HeaderRow, extraProps, _isSlot$1(slots) ? slots : {
    default: () => [slots]
  });
};
var Header = HeaderRenderer;
const HeaderCell$1 = (props, {
  slots
}) => renderSlot(slots, "default", props, () => {
  var _a, _b;
  return [createVNode("div", {
    "class": props.class,
    "title": (_a = props.column) == null ? void 0 : _a.title
  }, [(_b = props.column) == null ? void 0 : _b.title])];
});
HeaderCell$1.displayName = "ElTableV2HeaderCell";
HeaderCell$1.inheritAttrs = false;
var HeaderCell$1$1 = HeaderCell$1;
const SortIcon = (props) => {
  const {
    sortOrder
  } = props;
  return createVNode("button", {
    "type": "button",
    "aria-label": props.ariaLabel,
    "class": props.class
  }, [createVNode(ElIcon, {
    "size": 14
  }, {
    default: () => [sortOrder === SortOrder.ASC ? createVNode(sort_up_default, null, null) : createVNode(sort_down_default, null, null)]
  })]);
};
var SortIcon$1 = SortIcon;
const HeaderCellRenderer = (props, {
  slots
}) => {
  const {
    column,
    ns,
    t: t6,
    style,
    onColumnSorted
  } = props;
  const cellStyle = enforceUnit(style);
  if (column.placeholderSign === placeholderSign) {
    return createVNode("div", {
      "class": ns.em("header-row-cell", "placeholder"),
      "style": cellStyle
    }, null);
  }
  const {
    headerCellRenderer,
    headerClass,
    sortable
  } = column;
  const cellProps = {
    ...props,
    class: ns.e("header-cell-text")
  };
  const columnCellRenderer = componentToSlot(headerCellRenderer);
  const Cell2 = columnCellRenderer ? columnCellRenderer(cellProps) : renderSlot(slots, "default", cellProps, () => [createVNode(HeaderCell$1$1, cellProps, null)]);
  const {
    sortBy,
    sortState,
    headerCellProps
  } = props;
  let sorting, sortOrder, ariaSort;
  if (sortState) {
    const order = sortState[column.key];
    sorting = Boolean(oppositeOrderMap[order]);
    sortOrder = sorting ? order : SortOrder.ASC;
  } else {
    sorting = column.key === sortBy.key;
    sortOrder = sorting ? sortBy.order : SortOrder.ASC;
  }
  if (sortOrder === SortOrder.ASC) {
    ariaSort = "ascending";
  } else if (sortOrder === SortOrder.DESC) {
    ariaSort = "descending";
  } else {
    ariaSort = void 0;
  }
  const cellKls = [ns.e("header-cell"), tryCall(headerClass, props, ""), column.align === Alignment.CENTER && ns.is("align-center"), column.align === Alignment.RIGHT && ns.is("align-right"), sortable && ns.is("sortable")];
  const cellWrapperProps = {
    ...tryCall(headerCellProps, props),
    onClick: column.sortable ? onColumnSorted : void 0,
    ariaSort: sortable ? ariaSort : void 0,
    class: cellKls,
    style: cellStyle,
    ["data-key"]: column.key
  };
  return createVNode("div", mergeProps(cellWrapperProps, {
    "role": "columnheader"
  }), [Cell2, sortable && createVNode(SortIcon$1, {
    "class": [ns.e("sort-icon"), sorting && ns.is("sorting")],
    "sortOrder": sortOrder,
    "ariaLabel": t6("el.table.sortLabel", {
      column: column.title || ""
    })
  }, null)]);
};
var HeaderCell = HeaderCellRenderer;
const Footer$1 = (props, {
  slots
}) => {
  var _a;
  return createVNode("div", {
    "class": props.class,
    "style": props.style
  }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
};
Footer$1.displayName = "ElTableV2Footer";
var Footer$1$1 = Footer$1;
const Footer = (props, {
  slots
}) => {
  const defaultSlot = renderSlot(slots, "default", {}, () => [createVNode(ElEmpty, null, null)]);
  return createVNode("div", {
    "class": props.class,
    "style": props.style
  }, [defaultSlot]);
};
Footer.displayName = "ElTableV2Empty";
var Empty = Footer;
const Overlay = (props, {
  slots
}) => {
  var _a;
  return createVNode("div", {
    "class": props.class,
    "style": props.style
  }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
};
Overlay.displayName = "ElTableV2Overlay";
var Overlay$1 = Overlay;
function _isSlot(s11) {
  return typeof s11 === "function" || Object.prototype.toString.call(s11) === "[object Object]" && !isVNode(s11);
}
const COMPONENT_NAME = "ElTableV2";
defineComponent({
  name: COMPONENT_NAME,
  props: tableV2Props,
  setup(props, {
    slots,
    expose
  }) {
    const ns = useNamespace("table-v2");
    const {
      t: t6
    } = useLocale();
    const {
      columnsStyles,
      fixedColumnsOnLeft,
      fixedColumnsOnRight,
      mainColumns,
      mainTableHeight,
      fixedTableHeight,
      leftTableWidth,
      rightTableWidth,
      data,
      depthMap,
      expandedRowKeys,
      hasFixedColumns,
      mainTableRef,
      leftTableRef,
      rightTableRef,
      isDynamic,
      isResetting,
      isScrolling,
      bodyWidth,
      emptyStyle,
      rootStyle,
      footerHeight,
      showEmpty,
      scrollTo,
      scrollToLeft,
      scrollToTop,
      scrollToRow,
      getRowHeight,
      onColumnSorted,
      onRowHeightChange,
      onRowHovered,
      onRowExpanded,
      onRowsRendered,
      onScroll,
      onVerticalScroll
    } = useTable(props);
    expose({
      scrollTo,
      scrollToLeft,
      scrollToTop,
      scrollToRow
    });
    provide(TableV2InjectionKey, {
      ns,
      isResetting,
      isScrolling
    });
    return () => {
      const {
        cache: cache2,
        cellProps,
        estimatedRowHeight,
        expandColumnKey: expandColumnKey2,
        fixedData,
        headerHeight,
        headerClass,
        headerProps,
        headerCellProps,
        sortBy,
        sortState,
        rowHeight,
        rowClass,
        rowEventHandlers,
        rowKey: rowKey2,
        rowProps,
        scrollbarAlwaysOn,
        indentSize,
        iconSize,
        useIsScrolling,
        vScrollbarSize,
        width
      } = props;
      const _data = unref(data);
      const mainTableProps = {
        cache: cache2,
        class: ns.e("main"),
        columns: unref(mainColumns),
        data: _data,
        fixedData,
        estimatedRowHeight,
        bodyWidth: unref(bodyWidth),
        headerHeight,
        headerWidth: unref(bodyWidth),
        height: unref(mainTableHeight),
        mainTableRef,
        rowKey: rowKey2,
        rowHeight,
        scrollbarAlwaysOn,
        scrollbarStartGap: 2,
        scrollbarEndGap: vScrollbarSize,
        useIsScrolling,
        width,
        getRowHeight,
        onRowsRendered,
        onScroll
      };
      const leftColumnsWidth = unref(leftTableWidth);
      const _fixedTableHeight = unref(fixedTableHeight);
      const leftTableProps = {
        cache: cache2,
        class: ns.e("left"),
        columns: unref(fixedColumnsOnLeft),
        data: _data,
        fixedData,
        estimatedRowHeight,
        leftTableRef,
        rowHeight,
        bodyWidth: leftColumnsWidth,
        headerWidth: leftColumnsWidth,
        headerHeight,
        height: _fixedTableHeight,
        rowKey: rowKey2,
        scrollbarAlwaysOn,
        scrollbarStartGap: 2,
        scrollbarEndGap: vScrollbarSize,
        useIsScrolling,
        width: leftColumnsWidth,
        getRowHeight,
        onScroll: onVerticalScroll
      };
      const rightColumnsWidth = unref(rightTableWidth);
      const rightTableProps = {
        cache: cache2,
        class: ns.e("right"),
        columns: unref(fixedColumnsOnRight),
        data: _data,
        fixedData,
        estimatedRowHeight,
        rightTableRef,
        rowHeight,
        bodyWidth: rightColumnsWidth,
        headerWidth: rightColumnsWidth,
        headerHeight,
        height: _fixedTableHeight,
        rowKey: rowKey2,
        scrollbarAlwaysOn,
        scrollbarStartGap: 2,
        scrollbarEndGap: vScrollbarSize,
        width: rightColumnsWidth,
        style: `${ns.cssVarName("table-scrollbar-size")}: ${vScrollbarSize}px`,
        useIsScrolling,
        getRowHeight,
        onScroll: onVerticalScroll
      };
      const _columnsStyles = unref(columnsStyles);
      const tableRowProps = {
        ns,
        depthMap: unref(depthMap),
        columnsStyles: _columnsStyles,
        expandColumnKey: expandColumnKey2,
        expandedRowKeys: unref(expandedRowKeys),
        estimatedRowHeight,
        hasFixedColumns: unref(hasFixedColumns),
        rowProps,
        rowClass,
        rowKey: rowKey2,
        rowEventHandlers,
        onRowHovered,
        onRowExpanded,
        onRowHeightChange
      };
      const tableCellProps = {
        cellProps,
        expandColumnKey: expandColumnKey2,
        indentSize,
        iconSize,
        rowKey: rowKey2,
        expandedRowKeys: unref(expandedRowKeys),
        ns,
        t: t6
      };
      const tableHeaderProps = {
        ns,
        headerClass,
        headerProps,
        columnsStyles: _columnsStyles
      };
      const tableHeaderCellProps = {
        ns,
        t: t6,
        sortBy,
        sortState,
        headerCellProps,
        onColumnSorted
      };
      const tableSlots = {
        row: (props2) => createVNode(Row, mergeProps(props2, tableRowProps), {
          row: slots.row,
          cell: (props3) => {
            let _slot;
            return slots.cell ? createVNode(Cell, mergeProps(props3, tableCellProps, {
              "style": _columnsStyles[props3.column.key]
            }), _isSlot(_slot = slots.cell(props3)) ? _slot : {
              default: () => [_slot]
            }) : createVNode(Cell, mergeProps(props3, tableCellProps, {
              "style": _columnsStyles[props3.column.key]
            }), null);
          }
        }),
        header: (props2) => createVNode(Header, mergeProps(props2, tableHeaderProps), {
          header: slots.header,
          cell: (props3) => {
            let _slot2;
            return slots["header-cell"] ? createVNode(HeaderCell, mergeProps(props3, tableHeaderCellProps, {
              "style": _columnsStyles[props3.column.key]
            }), _isSlot(_slot2 = slots["header-cell"](props3)) ? _slot2 : {
              default: () => [_slot2]
            }) : createVNode(HeaderCell, mergeProps(props3, tableHeaderCellProps, {
              "style": _columnsStyles[props3.column.key]
            }), null);
          }
        })
      };
      const rootKls = [props.class, ns.b(), ns.e("root"), ns.is("dynamic", unref(isDynamic))];
      const footerProps = {
        class: ns.e("footer"),
        style: unref(footerHeight)
      };
      return createVNode("div", {
        "class": rootKls,
        "style": unref(rootStyle)
      }, [createVNode(MainTable$1, mainTableProps, _isSlot(tableSlots) ? tableSlots : {
        default: () => [tableSlots]
      }), createVNode(LeftTable$1, leftTableProps, _isSlot(tableSlots) ? tableSlots : {
        default: () => [tableSlots]
      }), createVNode(RightTable$1, rightTableProps, _isSlot(tableSlots) ? tableSlots : {
        default: () => [tableSlots]
      }), slots.footer && createVNode(Footer$1$1, footerProps, {
        default: slots.footer
      }), unref(showEmpty) && createVNode(Empty, {
        "class": ns.e("empty"),
        "style": unref(emptyStyle)
      }, {
        default: slots.empty
      }), slots.overlay && createVNode(Overlay$1, {
        "class": ns.e("overlay")
      }, {
        default: slots.overlay
      })]);
    };
  }
});
buildProps({
  disableWidth: Boolean,
  disableHeight: Boolean,
  onResize: {
    type: definePropType(Function)
  }
});
const textProps = buildProps({
  type: {
    type: String,
    values: ["primary", "success", "info", "warning", "danger", ""],
    default: ""
  },
  size: {
    type: String,
    values: componentSizes,
    default: ""
  },
  truncated: Boolean,
  lineClamp: {
    type: [String, Number]
  },
  tag: {
    type: String,
    default: "span"
  }
});
const _sfc_main$3 = defineComponent({
  ...{
    name: "ElText"
  },
  __name: "text",
  props: textProps,
  setup(__props) {
    const props = __props;
    const textRef = ref();
    const textSize = useFormSize();
    const ns = useNamespace("text");
    const textKls = computed(() => [
      ns.b(),
      ns.m(props.type),
      ns.m(textSize.value),
      ns.is("truncated", props.truncated),
      ns.is("line-clamp", !isUndefined$1(props.lineClamp))
    ]);
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
        ref_key: "textRef",
        ref: textRef,
        class: normalizeClass(textKls.value),
        style: normalizeStyle({ "-webkit-line-clamp": _ctx.lineClamp })
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["class", "style"]);
    };
  }
});
var Text = /* @__PURE__ */ _export_sfc$1(_sfc_main$3, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/text/src/text.vue"]]);
const ElText = withInstall(Text);
buildProps({
  format: {
    type: String,
    default: "HH:mm"
  },
  modelValue: {
    type: definePropType(String)
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  editable: {
    type: Boolean,
    default: true
  },
  effect: {
    type: definePropType(String),
    default: "light"
  },
  clearable: {
    type: Boolean,
    default: true
  },
  size: useSizeProp,
  placeholder: String,
  start: {
    type: String,
    default: "09:00"
  },
  end: {
    type: String,
    default: "18:00"
  },
  step: {
    type: String,
    default: "00:30"
  },
  minTime: {
    type: definePropType(String)
  },
  maxTime: {
    type: definePropType(String)
  },
  includeEndTime: Boolean,
  name: String,
  prefixIcon: {
    type: definePropType([String, Object]),
    default: () => clock_default
  },
  clearIcon: {
    type: definePropType([String, Object]),
    default: () => circle_close_default
  },
  popperClass: {
    type: String,
    default: ""
  },
  popperStyle: {
    type: definePropType([String, Object])
  },
  ...useEmptyValuesProps
});
const TIMELINE_INJECTION_KEY = "timeline";
const timelineProps = buildProps({
  mode: {
    type: String,
    values: ["start", "alternate", "alternate-reverse", "end"],
    default: "start"
  },
  reverse: Boolean
});
defineComponent({
  name: "ElTimeline",
  props: timelineProps,
  setup(props, { slots }) {
    const ns = useNamespace("timeline");
    provide(TIMELINE_INJECTION_KEY, { props, slots });
    const timelineKls = computed(() => [ns.b(), ns.is(props.mode)]);
    return () => {
      var _a, _b;
      const children = flattedChildren(
        (_b = (_a = slots.default) == null ? void 0 : _a.call(slots)) != null ? _b : []
      );
      return h(
        "ul",
        { class: timelineKls.value },
        props.reverse ? children.reverse() : children
      );
    };
  }
});
buildProps({
  timestamp: {
    type: String,
    default: ""
  },
  hideTimestamp: Boolean,
  center: Boolean,
  placement: {
    type: String,
    values: ["top", "bottom"],
    default: "bottom"
  },
  type: {
    type: String,
    values: ["primary", "success", "warning", "danger", "info"],
    default: ""
  },
  color: {
    type: String,
    default: ""
  },
  size: {
    type: String,
    values: ["normal", "large"],
    default: "normal"
  },
  icon: {
    type: iconPropType
  },
  hollow: Boolean
});
buildProps({
  data: {
    type: definePropType(Array),
    default: () => []
  },
  titles: {
    type: definePropType(Array),
    default: () => []
  },
  buttonTexts: {
    type: definePropType(Array),
    default: () => []
  },
  filterPlaceholder: String,
  filterMethod: {
    type: definePropType(
      Function
    )
  },
  leftDefaultChecked: {
    type: definePropType(Array),
    default: () => []
  },
  rightDefaultChecked: {
    type: definePropType(Array),
    default: () => []
  },
  renderContent: {
    type: definePropType(Function)
  },
  modelValue: {
    type: definePropType(Array),
    default: () => []
  },
  format: {
    type: definePropType(Object),
    default: () => ({})
  },
  filterable: Boolean,
  props: {
    type: definePropType(Object),
    default: () => mutable({
      label: "label",
      key: "key",
      disabled: "disabled"
    })
  },
  targetOrder: {
    type: String,
    values: ["original", "push", "unshift"],
    default: "original"
  },
  validateEvent: {
    type: Boolean,
    default: true
  }
});
const NODE_KEY = "$treeNodeId";
const markNodeData = function(node, data) {
  if (!data || data[NODE_KEY])
    return;
  Object.defineProperty(data, NODE_KEY, {
    value: node.id,
    enumerable: false,
    configurable: false,
    writable: false
  });
};
const getNodeKey = (key, data) => data == null ? void 0 : data[key || NODE_KEY];
const handleCurrentChange = (store, emit, setCurrent) => {
  const preCurrentNode = store.value.currentNode;
  setCurrent();
  const currentNode = store.value.currentNode;
  if (preCurrentNode === currentNode)
    return;
  emit("current-change", currentNode ? currentNode.data : null, currentNode);
};
const getChildState = (node) => {
  let all = true;
  let none = true;
  let allWithoutDisable = true;
  let isEffectivelyChecked = true;
  for (let i8 = 0, j5 = node.length; i8 < j5; i8++) {
    const n5 = node[i8];
    if (n5.checked !== true || n5.indeterminate) {
      all = false;
      if (!n5.disabled) {
        allWithoutDisable = false;
      }
    }
    if (n5.checked !== false || n5.indeterminate) {
      none = false;
    }
    if (!n5.isEffectivelyChecked) {
      isEffectivelyChecked = false;
    }
  }
  return {
    all,
    none,
    allWithoutDisable,
    half: !all && !none,
    isEffectivelyChecked
  };
};
const reInitChecked = function(node) {
  if (node.childNodes.length === 0 || node.loading) {
    node.isEffectivelyChecked = node.disabled || node.checked;
    return;
  }
  const { all, none, half, isEffectivelyChecked } = getChildState(
    node.childNodes
  );
  node.isEffectivelyChecked = isEffectivelyChecked;
  if (all) {
    node.checked = true;
    node.indeterminate = false;
  } else if (half) {
    node.checked = false;
    node.indeterminate = true;
  } else if (none) {
    node.checked = false;
    node.indeterminate = false;
  }
  const parent = node.parent;
  if (!parent || parent.level === 0)
    return;
  if (!node.store.checkStrictly) {
    reInitChecked(parent);
  }
};
const getPropertyFromData = function(node, prop) {
  const props = node.store.props;
  const data = node.data || {};
  const config = props[prop];
  if (isFunction(config)) {
    return config(data, node);
  } else if (isString(config)) {
    return data[config];
  } else if (isUndefined$1(config)) {
    const dataProp = data[prop];
    return isUndefined$1(dataProp) ? "" : dataProp;
  }
};
const setCanFocus = function(childNodes, focus) {
  childNodes.forEach((item) => {
    item.canFocus = focus;
    setCanFocus(item.childNodes, focus);
  });
};
let nodeIdSeed = 0;
class Node2 {
  constructor(options) {
    this.isLeafByUser = void 0;
    this.isLeaf = void 0;
    this.isEffectivelyChecked = false;
    this.id = nodeIdSeed++;
    this.text = null;
    this.checked = false;
    this.indeterminate = false;
    this.data = null;
    this.expanded = false;
    this.parent = null;
    this.visible = true;
    this.isCurrent = false;
    this.canFocus = false;
    for (const name in options) {
      if (hasOwn(options, name)) {
        this[name] = options[name];
      }
    }
    this.level = 0;
    this.loaded = false;
    this.childNodes = [];
    this.loading = false;
    if (this.parent) {
      this.level = this.parent.level + 1;
    }
  }
  initialize() {
    var _a;
    const store = this.store;
    if (!store) {
      throw new Error("[Node]store is required!");
    }
    store.registerNode(this);
    const props = store.props;
    if (props && typeof props.isLeaf !== "undefined") {
      const isLeaf2 = getPropertyFromData(this, "isLeaf");
      if (isBoolean$1(isLeaf2)) {
        this.isLeafByUser = isLeaf2;
      }
    }
    if (store.lazy !== true && this.data) {
      this.setData(this.data);
      if (store.defaultExpandAll) {
        this.expanded = true;
        this.canFocus = true;
      }
    } else if (this.level > 0 && store.lazy && store.defaultExpandAll && !this.isLeafByUser) {
      this.expand();
    }
    if (!isArray(this.data)) {
      markNodeData(this, this.data);
    }
    if (!this.data)
      return;
    const defaultExpandedKeys = store.defaultExpandedKeys;
    const key = store.key;
    if (key && !isNil(this.key) && defaultExpandedKeys && defaultExpandedKeys.includes(this.key)) {
      this.expand(null, store.autoExpandParent);
    }
    if (key && store.currentNodeKey !== void 0 && this.key === store.currentNodeKey) {
      store.currentNode && (store.currentNode.isCurrent = false);
      store.currentNode = this;
      store.currentNode.isCurrent = true;
    }
    if (store.lazy) {
      store._initDefaultCheckedNode(this);
    }
    this.updateLeafState();
    if (this.level === 1 || ((_a = this.parent) == null ? void 0 : _a.expanded) === true)
      this.canFocus = true;
  }
  setData(data) {
    if (!isArray(data)) {
      markNodeData(this, data);
    }
    this.data = data;
    this.childNodes = [];
    let children;
    if (this.level === 0 && isArray(this.data)) {
      children = this.data;
    } else {
      children = getPropertyFromData(this, "children") || [];
    }
    for (let i8 = 0, j5 = children.length; i8 < j5; i8++) {
      this.insertChild({ data: children[i8] });
    }
  }
  get label() {
    return getPropertyFromData(this, "label");
  }
  get key() {
    const nodeKey = this.store.key;
    if (this.data)
      return this.data[nodeKey];
    return null;
  }
  get disabled() {
    return getPropertyFromData(this, "disabled");
  }
  get nextSibling() {
    const parent = this.parent;
    if (parent) {
      const index = parent.childNodes.indexOf(this);
      if (index > -1) {
        return parent.childNodes[index + 1];
      }
    }
    return null;
  }
  get previousSibling() {
    const parent = this.parent;
    if (parent) {
      const index = parent.childNodes.indexOf(this);
      if (index > -1) {
        return index > 0 ? parent.childNodes[index - 1] : null;
      }
    }
    return null;
  }
  contains(target, deep = true) {
    return (this.childNodes || []).some(
      (child) => child === target || deep && child.contains(target)
    );
  }
  remove() {
    const parent = this.parent;
    if (parent) {
      parent.removeChild(this);
    }
  }
  insertChild(child, index, batch) {
    if (!child)
      throw new Error("InsertChild error: child is required.");
    if (!(child instanceof Node2)) {
      if (!batch) {
        const children = this.getChildren(true);
        if (!(children == null ? void 0 : children.includes(child.data))) {
          if (isUndefined$1(index) || index < 0) {
            children == null ? void 0 : children.push(child.data);
          } else {
            children == null ? void 0 : children.splice(index, 0, child.data);
          }
        }
      }
      Object.assign(child, {
        parent: this,
        store: this.store
      });
      child = reactive(new Node2(child));
      if (child instanceof Node2) {
        child.initialize();
      }
    }
    child.level = this.level + 1;
    if (isUndefined$1(index) || index < 0) {
      this.childNodes.push(child);
    } else {
      this.childNodes.splice(index, 0, child);
    }
    this.updateLeafState();
  }
  insertBefore(child, ref2) {
    let index;
    if (ref2) {
      index = this.childNodes.indexOf(ref2);
    }
    this.insertChild(child, index);
  }
  insertAfter(child, ref2) {
    let index;
    if (ref2) {
      index = this.childNodes.indexOf(ref2);
      if (index !== -1)
        index += 1;
    }
    this.insertChild(child, index);
  }
  removeChild(child) {
    const children = this.getChildren() || [];
    const dataIndex = children.indexOf(child.data);
    if (dataIndex > -1) {
      children.splice(dataIndex, 1);
    }
    const index = this.childNodes.indexOf(child);
    if (index > -1) {
      this.store && this.store.deregisterNode(child);
      child.parent = null;
      this.childNodes.splice(index, 1);
    }
    this.updateLeafState();
  }
  removeChildByData(data) {
    const targetNode = this.childNodes.find((child) => child.data === data);
    if (targetNode) {
      this.removeChild(targetNode);
    }
  }
  expand(callback, expandParent) {
    const done = () => {
      if (expandParent) {
        let parent = this.parent;
        while (parent && parent.level > 0) {
          parent.expanded = true;
          parent = parent.parent;
        }
      }
      this.expanded = true;
      if (callback)
        callback();
      setCanFocus(this.childNodes, true);
    };
    if (this.shouldLoadData()) {
      this.loadData((data) => {
        if (isArray(data)) {
          if (this.checked) {
            this.setChecked(true, true);
          } else if (!this.store.checkStrictly) {
            reInitChecked(this);
          }
          done();
        }
      });
    } else {
      done();
    }
  }
  doCreateChildren(array, defaultProps2 = {}) {
    array.forEach((item) => {
      this.insertChild(
        Object.assign({ data: item }, defaultProps2),
        void 0,
        true
      );
    });
  }
  collapse() {
    this.expanded = false;
    setCanFocus(this.childNodes, false);
  }
  shouldLoadData() {
    return Boolean(this.store.lazy === true && this.store.load && !this.loaded);
  }
  updateLeafState() {
    if (this.store.lazy === true && this.loaded !== true && typeof this.isLeafByUser !== "undefined") {
      this.isLeaf = this.isLeafByUser;
      this.isEffectivelyChecked = this.isLeaf && this.disabled;
      return;
    }
    const childNodes = this.childNodes;
    if (!this.store.lazy || this.store.lazy === true && this.loaded === true) {
      this.isLeaf = !childNodes || childNodes.length === 0;
      this.isEffectivelyChecked = this.isLeaf && this.disabled;
      return;
    }
    this.isLeaf = false;
  }
  setChecked(value, deep, recursion, passValue) {
    this.indeterminate = value === "half";
    this.checked = value === true;
    this.isEffectivelyChecked = !this.childNodes.length && (this.disabled || this.checked);
    if (this.store.checkStrictly)
      return;
    if (!(this.shouldLoadData() && !this.store.checkDescendants)) {
      const handleDescendants = () => {
        if (deep) {
          const childNodes = this.childNodes;
          for (let i8 = 0, j5 = childNodes.length; i8 < j5; i8++) {
            const child = childNodes[i8];
            passValue = passValue || value !== false;
            const isCheck = child.disabled && child.isLeaf ? child.checked : passValue;
            child.setChecked(isCheck, deep, true, passValue);
          }
          const { half, all, isEffectivelyChecked } = getChildState(childNodes);
          if (!all) {
            this.checked = all;
            this.indeterminate = half;
          }
          this.isEffectivelyChecked = !this.childNodes.length ? this.disabled || this.checked : isEffectivelyChecked;
        }
      };
      if (this.shouldLoadData()) {
        this.loadData(
          () => {
            handleDescendants();
            reInitChecked(this);
          },
          {
            checked: value !== false
          }
        );
        return;
      } else {
        handleDescendants();
      }
    }
    const parent = this.parent;
    if (!parent || parent.level === 0)
      return;
    if (!recursion) {
      reInitChecked(parent);
    }
  }
  getChildren(forceInit = false) {
    if (this.level === 0)
      return this.data;
    const data = this.data;
    if (!data)
      return null;
    const props = this.store.props;
    let children = "children";
    if (props) {
      children = props.children || "children";
    }
    if (isUndefined$1(data[children])) {
      data[children] = null;
    }
    if (forceInit && !data[children]) {
      data[children] = [];
    }
    return data[children];
  }
  updateChildren() {
    const newData = this.getChildren() || [];
    const oldData = this.childNodes.map((node) => node.data);
    const newDataMap = {};
    const newNodes = [];
    newData.forEach((item, index) => {
      const key = item[NODE_KEY];
      const isNodeExists = !!key && oldData.some((data) => (data == null ? void 0 : data[NODE_KEY]) === key);
      if (isNodeExists) {
        newDataMap[key] = { index, data: item };
      } else {
        newNodes.push({ index, data: item });
      }
    });
    if (!this.store.lazy) {
      oldData.forEach((item) => {
        if (!newDataMap[item == null ? void 0 : item[NODE_KEY]])
          this.removeChildByData(item);
      });
    }
    newNodes.forEach(({ index, data }) => {
      this.insertChild({ data }, index);
    });
    this.updateLeafState();
  }
  loadData(callback, defaultProps2 = {}) {
    if (this.store.lazy === true && this.store.load && !this.loaded && (!this.loading || Object.keys(defaultProps2).length)) {
      this.loading = true;
      const resolve = (children) => {
        this.childNodes = [];
        this.doCreateChildren(children, defaultProps2);
        this.loaded = true;
        this.loading = false;
        this.updateLeafState();
        if (callback) {
          callback.call(this, children);
        }
      };
      const reject = () => {
        this.loading = false;
      };
      this.store.load(this, resolve, reject);
    } else {
      if (callback) {
        callback.call(this);
      }
    }
  }
  eachNode(callback) {
    const arr = [this];
    while (arr.length) {
      const node = arr.shift();
      arr.unshift(...node.childNodes);
      callback(node);
    }
  }
  reInitChecked() {
    if (this.store.checkStrictly)
      return;
    reInitChecked(this);
  }
}
class TreeStore {
  constructor(options) {
    this.lazy = false;
    this.checkStrictly = false;
    this.autoExpandParent = false;
    this.defaultExpandAll = false;
    this.checkDescendants = false;
    this.currentNode = null;
    this.currentNodeKey = null;
    for (const option in options) {
      if (hasOwn(options, option)) {
        this[option] = options[option];
      }
    }
    this.nodesMap = {};
  }
  initialize() {
    this.root = new Node2({
      data: this.data,
      store: this
    });
    this.root.initialize();
    if (this.lazy && this.load) {
      const loadFn = this.load;
      loadFn(
        this.root,
        (data) => {
          this.root.doCreateChildren(data);
          this._initDefaultCheckedNodes();
        },
        NOOP
      );
    } else {
      this._initDefaultCheckedNodes();
    }
  }
  filter(value) {
    const filterNodeMethod = this.filterNodeMethod;
    const lazy = this.lazy;
    const traverse = async function(node) {
      const childNodes = node.root ? node.root.childNodes : node.childNodes;
      for (const [index, child] of childNodes.entries()) {
        child.visible = !!(filterNodeMethod == null ? void 0 : filterNodeMethod.call(
          child,
          value,
          child.data,
          child
        ));
        if (index % 80 === 0 && index > 0) {
          await nextTick();
        }
        await traverse(child);
      }
      if (!node.visible && childNodes.length) {
        let allHidden = true;
        allHidden = !childNodes.some((child) => child.visible);
        if (node.root) {
          node.root.visible = allHidden === false;
        } else {
          node.visible = allHidden === false;
        }
      }
      if (!value)
        return;
      if (node.visible && !node.isLeaf) {
        if (!lazy || node.loaded) {
          node.expand();
        }
      }
    };
    traverse(this);
  }
  setData(newVal) {
    const instanceChanged = newVal !== this.root.data;
    if (instanceChanged) {
      this.nodesMap = {};
      this.root.setData(newVal);
      this._initDefaultCheckedNodes();
      this.setCurrentNodeKey(this.currentNodeKey);
    } else {
      this.root.updateChildren();
    }
  }
  getNode(data) {
    if (data instanceof Node2)
      return data;
    const key = isObject(data) ? getNodeKey(this.key, data) : data;
    return this.nodesMap[key] || null;
  }
  insertBefore(data, refData) {
    var _a;
    const refNode = this.getNode(refData);
    (_a = refNode.parent) == null ? void 0 : _a.insertBefore({ data }, refNode);
  }
  insertAfter(data, refData) {
    var _a;
    const refNode = this.getNode(refData);
    (_a = refNode.parent) == null ? void 0 : _a.insertAfter({ data }, refNode);
  }
  remove(data) {
    const node = this.getNode(data);
    if (node && node.parent) {
      if (node === this.currentNode) {
        this.currentNode = null;
      }
      node.parent.removeChild(node);
    }
  }
  append(data, parentData) {
    const parentNode = !isPropAbsent(parentData) ? this.getNode(parentData) : this.root;
    if (parentNode) {
      parentNode.insertChild({ data });
    }
  }
  _initDefaultCheckedNodes() {
    const defaultCheckedKeys = this.defaultCheckedKeys || [];
    const nodesMap = this.nodesMap;
    defaultCheckedKeys.forEach((checkedKey) => {
      const node = nodesMap[checkedKey];
      if (node) {
        node.setChecked(true, !this.checkStrictly);
      }
    });
  }
  _initDefaultCheckedNode(node) {
    const defaultCheckedKeys = this.defaultCheckedKeys || [];
    if (!isNil(node.key) && defaultCheckedKeys.includes(node.key)) {
      node.setChecked(true, !this.checkStrictly);
    }
  }
  setDefaultCheckedKey(newVal) {
    if (newVal !== this.defaultCheckedKeys) {
      this.defaultCheckedKeys = newVal;
      this._initDefaultCheckedNodes();
    }
  }
  registerNode(node) {
    const key = this.key;
    if (!node || !node.data)
      return;
    if (!key) {
      this.nodesMap[node.id] = node;
    } else {
      const nodeKey = node.key;
      if (!isNil(nodeKey))
        this.nodesMap[nodeKey] = node;
    }
  }
  deregisterNode(node) {
    const key = this.key;
    if (!key || !node || !node.data)
      return;
    node.childNodes.forEach((child) => {
      this.deregisterNode(child);
    });
    delete this.nodesMap[node.key];
  }
  getCheckedNodes(leafOnly = false, includeHalfChecked = false) {
    const checkedNodes = [];
    const traverse = function(node) {
      const childNodes = node.root ? node.root.childNodes : node.childNodes;
      childNodes.forEach((child) => {
        if ((child.checked || includeHalfChecked && child.indeterminate) && (!leafOnly || leafOnly && child.isLeaf)) {
          checkedNodes.push(child.data);
        }
        traverse(child);
      });
    };
    traverse(this);
    return checkedNodes;
  }
  getCheckedKeys(leafOnly = false) {
    return this.getCheckedNodes(leafOnly).map((data) => (data || {})[this.key]);
  }
  getHalfCheckedNodes() {
    const nodes = [];
    const traverse = function(node) {
      const childNodes = node.root ? node.root.childNodes : node.childNodes;
      childNodes.forEach((child) => {
        if (child.indeterminate) {
          nodes.push(child.data);
        }
        traverse(child);
      });
    };
    traverse(this);
    return nodes;
  }
  getHalfCheckedKeys() {
    return this.getHalfCheckedNodes().map((data) => (data || {})[this.key]);
  }
  _getAllNodes() {
    const allNodes = [];
    const nodesMap = this.nodesMap;
    for (const nodeKey in nodesMap) {
      if (hasOwn(nodesMap, nodeKey)) {
        allNodes.push(nodesMap[nodeKey]);
      }
    }
    return allNodes;
  }
  updateChildren(key, data) {
    const node = this.nodesMap[key];
    if (!node)
      return;
    const childNodes = node.childNodes;
    for (let i8 = childNodes.length - 1; i8 >= 0; i8--) {
      const child = childNodes[i8];
      this.remove(child.data);
    }
    for (let i8 = 0, j5 = data.length; i8 < j5; i8++) {
      const child = data[i8];
      this.append(child, node.data);
    }
  }
  _setCheckedKeys(key, leafOnly = false, checkedKeys) {
    const allNodes = this._getAllNodes().sort((a31, b23) => a31.level - b23.level);
    const cache2 = /* @__PURE__ */ Object.create(null);
    const keys = Object.keys(checkedKeys);
    allNodes.forEach((node) => node.setChecked(false, false));
    const cacheCheckedChild = (node) => {
      node.childNodes.forEach((child) => {
        var _a;
        cache2[child.data[key]] = true;
        if ((_a = child.childNodes) == null ? void 0 : _a.length) {
          cacheCheckedChild(child);
        }
      });
    };
    for (let i8 = 0, j5 = allNodes.length; i8 < j5; i8++) {
      const node = allNodes[i8];
      const nodeKey = node.data[key].toString();
      const checked = keys.includes(nodeKey);
      if (!checked) {
        if (node.checked && !cache2[nodeKey]) {
          node.setChecked(false, false);
        }
        continue;
      }
      if (node.childNodes.length) {
        cacheCheckedChild(node);
      }
      if (node.isLeaf || this.checkStrictly) {
        node.setChecked(true, false);
        continue;
      }
      node.setChecked(true, true);
      if (leafOnly) {
        node.setChecked(false, false);
        const traverse = function(node2) {
          const childNodes = node2.childNodes;
          childNodes.forEach((child) => {
            if (!child.isLeaf) {
              child.setChecked(false, false);
            }
            traverse(child);
          });
        };
        traverse(node);
      }
    }
  }
  setCheckedNodes(array, leafOnly = false) {
    const key = this.key;
    const checkedKeys = {};
    array.forEach((item) => {
      checkedKeys[(item || {})[key]] = true;
    });
    this._setCheckedKeys(key, leafOnly, checkedKeys);
  }
  setCheckedKeys(keys, leafOnly = false) {
    this.defaultCheckedKeys = keys;
    const key = this.key;
    const checkedKeys = {};
    keys.forEach((key2) => {
      checkedKeys[key2] = true;
    });
    this._setCheckedKeys(key, leafOnly, checkedKeys);
  }
  setDefaultExpandedKeys(keys) {
    keys = keys || [];
    this.defaultExpandedKeys = keys;
    keys.forEach((key) => {
      const node = this.getNode(key);
      if (node)
        node.expand(null, this.autoExpandParent);
    });
  }
  setChecked(data, checked, deep) {
    const node = this.getNode(data);
    if (node) {
      node.setChecked(!!checked, deep);
    }
  }
  getCurrentNode() {
    return this.currentNode;
  }
  setCurrentNode(currentNode) {
    const prevCurrentNode = this.currentNode;
    if (prevCurrentNode) {
      prevCurrentNode.isCurrent = false;
    }
    this.currentNode = currentNode;
    this.currentNode.isCurrent = true;
  }
  setUserCurrentNode(node, shouldAutoExpandParent = true) {
    var _a;
    const key = node[this.key];
    const currNode = this.nodesMap[key];
    this.setCurrentNode(currNode);
    if (shouldAutoExpandParent && this.currentNode && this.currentNode.level > 1) {
      (_a = this.currentNode.parent) == null ? void 0 : _a.expand(null, true);
    }
  }
  setCurrentNodeKey(key, shouldAutoExpandParent = true) {
    var _a;
    this.currentNodeKey = key;
    if (isPropAbsent(key)) {
      this.currentNode && (this.currentNode.isCurrent = false);
      this.currentNode = null;
      return;
    }
    const node = this.getNode(key);
    if (node) {
      this.setCurrentNode(node);
      if (shouldAutoExpandParent && this.currentNode && this.currentNode.level > 1) {
        (_a = this.currentNode.parent) == null ? void 0 : _a.expand(null, true);
      }
    }
  }
}
const ROOT_TREE_INJECTION_KEY = "RootTree";
const NODE_INSTANCE_INJECTION_KEY = "NodeInstance";
const TREE_NODE_MAP_INJECTION_KEY = "TreeNodeMap";
const _sfc_main$2 = defineComponent({
  name: "ElTreeNodeContent",
  props: {
    node: {
      type: Object,
      required: true
    },
    renderContent: Function
  },
  setup(props) {
    const ns = useNamespace("tree");
    const nodeInstance = inject(
      NODE_INSTANCE_INJECTION_KEY
    );
    const tree = inject(ROOT_TREE_INJECTION_KEY);
    return () => {
      const node = props.node;
      const { data, store } = node;
      return props.renderContent ? props.renderContent(h, { _self: nodeInstance, node, data, store }) : renderSlot(tree.ctx.slots, "default", { node, data }, () => [
        h(
          ElText,
          { tag: "span", truncated: true, class: ns.be("node", "label") },
          () => [node.label]
        )
      ]);
    };
  }
});
var NodeContent = /* @__PURE__ */ _export_sfc$1(_sfc_main$2, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree/src/tree-node-content.vue"]]);
function useNodeExpandEventBroadcast(props) {
  const parentNodeMap = inject(
    TREE_NODE_MAP_INJECTION_KEY,
    null
  );
  let currentNodeMap = {
    treeNodeExpand: (node) => {
      var _a;
      if (props.node !== node) {
        (_a = props.node) == null ? void 0 : _a.collapse();
      }
    },
    children: /* @__PURE__ */ new Set()
  };
  if (parentNodeMap) {
    parentNodeMap.children.add(currentNodeMap);
  }
  provide(TREE_NODE_MAP_INJECTION_KEY, currentNodeMap);
  return {
    broadcastExpanded: (node) => {
      if (!props.accordion)
        return;
      for (const childNode of currentNodeMap.children) {
        childNode.treeNodeExpand(node);
      }
    }
  };
}
const dragEventsKey = /* @__PURE__ */ Symbol("dragEvents");
function useDragNodeHandler({
  props,
  ctx,
  el$,
  dropIndicator$,
  store
}) {
  const ns = useNamespace("tree");
  const dragState = ref({
    showDropIndicator: false,
    draggingNode: null,
    dropNode: null,
    allowDrop: true,
    dropType: null
  });
  const treeNodeDragStart = ({ event, treeNode }) => {
    if (!event.dataTransfer)
      return;
    if (isFunction(props.allowDrag) && !props.allowDrag(treeNode.node)) {
      event.preventDefault();
      return false;
    }
    event.dataTransfer.effectAllowed = "move";
    try {
      event.dataTransfer.setData("text/plain", "");
    } catch (e12) {
    }
    dragState.value.draggingNode = treeNode;
    ctx.emit("node-drag-start", treeNode.node, event);
  };
  const treeNodeDragOver = ({ event, treeNode }) => {
    if (!event.dataTransfer)
      return;
    const dropNode = treeNode;
    const oldDropNode = dragState.value.dropNode;
    if (oldDropNode && oldDropNode.node.id !== dropNode.node.id) {
      removeClass(oldDropNode.$el, ns.is("drop-inner"));
    }
    const draggingNode = dragState.value.draggingNode;
    if (!draggingNode || !dropNode)
      return;
    let dropPrev = true;
    let dropInner = true;
    let dropNext = true;
    let userAllowDropInner = true;
    if (isFunction(props.allowDrop)) {
      dropPrev = props.allowDrop(draggingNode.node, dropNode.node, "prev");
      userAllowDropInner = dropInner = props.allowDrop(
        draggingNode.node,
        dropNode.node,
        "inner"
      );
      dropNext = props.allowDrop(draggingNode.node, dropNode.node, "next");
    }
    event.dataTransfer.dropEffect = dropInner || dropPrev || dropNext ? "move" : "none";
    if ((dropPrev || dropInner || dropNext) && (oldDropNode == null ? void 0 : oldDropNode.node.id) !== dropNode.node.id) {
      if (oldDropNode) {
        ctx.emit("node-drag-leave", draggingNode.node, oldDropNode.node, event);
      }
      ctx.emit("node-drag-enter", draggingNode.node, dropNode.node, event);
    }
    if (dropPrev || dropInner || dropNext) {
      dragState.value.dropNode = dropNode;
    } else {
      dragState.value.dropNode = null;
    }
    if (dropNode.node.nextSibling === draggingNode.node) {
      dropNext = false;
    }
    if (dropNode.node.previousSibling === draggingNode.node) {
      dropPrev = false;
    }
    if (dropNode.node.contains(draggingNode.node, false)) {
      dropInner = false;
    }
    if (draggingNode.node === dropNode.node || draggingNode.node.contains(dropNode.node)) {
      dropPrev = false;
      dropInner = false;
      dropNext = false;
    }
    const dropEl = dropNode.$el;
    const targetPosition = dropEl.querySelector(`.${ns.be("node", "content")}`).getBoundingClientRect();
    const treePosition = el$.value.getBoundingClientRect();
    const treeScrollTop = el$.value.scrollTop;
    let dropType;
    const prevPercent = dropPrev ? dropInner ? 0.25 : dropNext ? 0.45 : 1 : Number.NEGATIVE_INFINITY;
    const nextPercent = dropNext ? dropInner ? 0.75 : dropPrev ? 0.55 : 0 : Number.POSITIVE_INFINITY;
    let indicatorTop = -9999;
    const distance = event.clientY - targetPosition.top;
    if (distance < targetPosition.height * prevPercent) {
      dropType = "before";
    } else if (distance > targetPosition.height * nextPercent) {
      dropType = "after";
    } else if (dropInner) {
      dropType = "inner";
    } else {
      dropType = "none";
    }
    const iconPosition = dropEl.querySelector(`.${ns.be("node", "expand-icon")}`).getBoundingClientRect();
    const dropIndicator = dropIndicator$.value;
    if (dropType === "before") {
      indicatorTop = iconPosition.top - treePosition.top + treeScrollTop;
    } else if (dropType === "after") {
      indicatorTop = iconPosition.bottom - treePosition.top + treeScrollTop;
    }
    dropIndicator.style.top = `${indicatorTop}px`;
    dropIndicator.style.left = `${iconPosition.right - treePosition.left}px`;
    if (dropType === "inner") {
      addClass(dropEl, ns.is("drop-inner"));
    } else {
      removeClass(dropEl, ns.is("drop-inner"));
    }
    dragState.value.showDropIndicator = dropType === "before" || dropType === "after";
    dragState.value.allowDrop = dragState.value.showDropIndicator || userAllowDropInner;
    dragState.value.dropType = dropType;
    ctx.emit("node-drag-over", draggingNode.node, dropNode.node, event);
  };
  const treeNodeDragEnd = (event) => {
    var _a, _b;
    const { draggingNode, dropType, dropNode } = dragState.value;
    event.preventDefault();
    if (event.dataTransfer) {
      event.dataTransfer.dropEffect = "move";
    }
    if ((draggingNode == null ? void 0 : draggingNode.node.data) && dropNode) {
      const draggingNodeCopy = { data: draggingNode.node.data };
      if (dropType !== "none") {
        draggingNode.node.remove();
      }
      if (dropType === "before") {
        (_a = dropNode.node.parent) == null ? void 0 : _a.insertBefore(draggingNodeCopy, dropNode.node);
      } else if (dropType === "after") {
        (_b = dropNode.node.parent) == null ? void 0 : _b.insertAfter(draggingNodeCopy, dropNode.node);
      } else if (dropType === "inner") {
        dropNode.node.insertChild(draggingNodeCopy);
      }
      if (dropType !== "none") {
        store.value.registerNode(draggingNodeCopy);
        if (store.value.key) {
          draggingNode.node.eachNode((node) => {
            var _a2;
            (_a2 = store.value.nodesMap[node.data[store.value.key]]) == null ? void 0 : _a2.setChecked(
              node.checked,
              !store.value.checkStrictly
            );
          });
        }
      }
      removeClass(dropNode.$el, ns.is("drop-inner"));
      ctx.emit(
        "node-drag-end",
        draggingNode.node,
        dropNode.node,
        dropType,
        event
      );
      if (dropType !== "none") {
        ctx.emit(
          "node-drop",
          draggingNode.node,
          dropNode.node,
          dropType,
          event
        );
      }
    }
    if (draggingNode && !dropNode) {
      ctx.emit("node-drag-end", draggingNode.node, null, dropType, event);
    }
    dragState.value.showDropIndicator = false;
    dragState.value.draggingNode = null;
    dragState.value.dropNode = null;
    dragState.value.allowDrop = true;
  };
  provide(dragEventsKey, {
    treeNodeDragStart,
    treeNodeDragOver,
    treeNodeDragEnd
  });
  return {
    dragState
  };
}
const _sfc_main$1 = defineComponent({
  name: "ElTreeNode",
  components: {
    ElCollapseTransition,
    ElCheckbox,
    NodeContent,
    ElIcon,
    Loading: loading_default
  },
  props: {
    node: {
      type: Node2,
      default: () => ({})
    },
    props: {
      type: Object,
      default: () => ({})
    },
    accordion: Boolean,
    renderContent: Function,
    renderAfterExpand: Boolean,
    showCheckbox: Boolean
  },
  emits: ["node-expand"],
  setup(props, ctx) {
    const ns = useNamespace("tree");
    const { broadcastExpanded } = useNodeExpandEventBroadcast(props);
    const tree = inject(ROOT_TREE_INJECTION_KEY);
    const expanded = ref(false);
    const childNodeRendered = ref(false);
    const oldChecked = ref();
    const oldIndeterminate = ref();
    const node$ = ref();
    const dragEvents = inject(dragEventsKey);
    const instance = getCurrentInstance();
    provide(NODE_INSTANCE_INJECTION_KEY, instance);
    if (props.node.expanded) {
      expanded.value = true;
      childNodeRendered.value = true;
    }
    const childrenKey = tree.props.props["children"] || "children";
    watch(
      () => {
        var _a;
        const children = (_a = props.node.data) == null ? void 0 : _a[childrenKey];
        return children && [...children];
      },
      () => {
        props.node.updateChildren();
      }
    );
    watch(
      () => props.node.indeterminate,
      (val) => {
        handleSelectChange(props.node.checked, val);
      }
    );
    watch(
      () => props.node.checked,
      (val) => {
        handleSelectChange(val, props.node.indeterminate);
      }
    );
    watch(
      () => props.node.childNodes.length,
      () => props.node.reInitChecked()
    );
    watch(
      () => props.node.expanded,
      (val) => {
        nextTick(() => expanded.value = val);
        if (val) {
          childNodeRendered.value = true;
        }
      }
    );
    const getNodeKey$1 = (node) => {
      return getNodeKey(tree.props.nodeKey, node.data);
    };
    const getNodeClass = (node) => {
      const nodeClassFunc = props.props.class;
      if (!nodeClassFunc) {
        return {};
      }
      let className;
      if (isFunction(nodeClassFunc)) {
        const { data } = node;
        className = nodeClassFunc(data, node);
      } else {
        className = nodeClassFunc;
      }
      if (isString(className)) {
        return { [className]: true };
      } else {
        return className;
      }
    };
    const handleSelectChange = (checked, indeterminate) => {
      if (oldChecked.value !== checked || oldIndeterminate.value !== indeterminate) {
        tree.ctx.emit("check-change", props.node.data, checked, indeterminate);
      }
      oldChecked.value = checked;
      oldIndeterminate.value = indeterminate;
    };
    const handleClick = (e12) => {
      handleCurrentChange(tree.store, tree.ctx.emit, () => {
        var _a;
        const nodeKeyProp = (_a = tree == null ? void 0 : tree.props) == null ? void 0 : _a.nodeKey;
        if (nodeKeyProp) {
          const curNodeKey = getNodeKey$1(props.node);
          tree.store.value.setCurrentNodeKey(curNodeKey);
        } else {
          tree.store.value.setCurrentNode(props.node);
        }
      });
      tree.currentNode.value = props.node;
      if (tree.props.expandOnClickNode) {
        handleExpandIconClick();
      }
      if ((tree.props.checkOnClickNode || props.node.isLeaf && tree.props.checkOnClickLeaf && props.showCheckbox) && !props.node.disabled) {
        handleCheckChange(!props.node.checked);
      }
      tree.ctx.emit("node-click", props.node.data, props.node, instance, e12);
    };
    const handleContextMenu = (event) => {
      var _a;
      if ((_a = tree.instance.vnode.props) == null ? void 0 : _a["onNodeContextmenu"]) {
        event.stopPropagation();
        event.preventDefault();
      }
      tree.ctx.emit(
        "node-contextmenu",
        event,
        props.node.data,
        props.node,
        instance
      );
    };
    const handleExpandIconClick = () => {
      if (props.node.isLeaf)
        return;
      if (expanded.value) {
        tree.ctx.emit("node-collapse", props.node.data, props.node, instance);
        props.node.collapse();
      } else {
        props.node.expand(() => {
          ctx.emit("node-expand", props.node.data, props.node, instance);
        });
      }
    };
    const handleCheckChange = (value) => {
      const checkStrictly = tree == null ? void 0 : tree.props.checkStrictly;
      const childNodes = props.node.childNodes;
      if (!checkStrictly && childNodes.length) {
        value = childNodes.some((node) => !node.isEffectivelyChecked);
      }
      props.node.setChecked(value, !checkStrictly);
      nextTick(() => {
        const store = tree.store.value;
        tree.ctx.emit("check", props.node.data, {
          checkedNodes: store.getCheckedNodes(),
          checkedKeys: store.getCheckedKeys(),
          halfCheckedNodes: store.getHalfCheckedNodes(),
          halfCheckedKeys: store.getHalfCheckedKeys()
        });
      });
    };
    const handleChildNodeExpand = (nodeData, node, instance2) => {
      broadcastExpanded(node);
      tree.ctx.emit("node-expand", nodeData, node, instance2);
    };
    const handleDragStart = (event) => {
      if (!tree.props.draggable)
        return;
      dragEvents.treeNodeDragStart({ event, treeNode: props });
    };
    const handleDragOver = (event) => {
      event.preventDefault();
      if (!tree.props.draggable)
        return;
      dragEvents.treeNodeDragOver({
        event,
        treeNode: { $el: node$.value, node: props.node }
      });
    };
    const handleDrop = (event) => {
      event.preventDefault();
    };
    const handleDragEnd = (event) => {
      if (!tree.props.draggable)
        return;
      dragEvents.treeNodeDragEnd(event);
    };
    return {
      ns,
      node$,
      tree,
      expanded,
      childNodeRendered,
      oldChecked,
      oldIndeterminate,
      getNodeKey: getNodeKey$1,
      getNodeClass,
      handleSelectChange,
      handleClick,
      handleContextMenu,
      handleExpandIconClick,
      handleCheckChange,
      handleChildNodeExpand,
      handleDragStart,
      handleDragOver,
      handleDrop,
      handleDragEnd,
      CaretRight: caret_right_default
    };
  }
});
const _hoisted_1 = ["aria-expanded", "aria-disabled", "aria-checked", "draggable", "data-key"];
const _hoisted_2 = ["aria-expanded"];
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_icon = resolveComponent("el-icon");
  const _component_el_checkbox = resolveComponent("el-checkbox");
  const _component_loading = resolveComponent("loading");
  const _component_node_content = resolveComponent("node-content");
  const _component_el_tree_node = resolveComponent("el-tree-node");
  const _component_el_collapse_transition = resolveComponent("el-collapse-transition");
  return withDirectives((openBlock(), createElementBlock("div", {
    ref: "node$",
    class: normalizeClass([
      _ctx.ns.b("node"),
      _ctx.ns.is("expanded", _ctx.expanded),
      _ctx.ns.is("current", _ctx.node.isCurrent),
      _ctx.ns.is("hidden", !_ctx.node.visible),
      _ctx.ns.is("focusable", !_ctx.node.disabled),
      _ctx.ns.is("checked", !_ctx.node.disabled && _ctx.node.checked),
      _ctx.getNodeClass(_ctx.node)
    ]),
    role: "treeitem",
    tabindex: "-1",
    "aria-expanded": _ctx.expanded,
    "aria-disabled": _ctx.node.disabled,
    "aria-checked": _ctx.node.checked,
    draggable: _ctx.tree.props.draggable,
    "data-key": _ctx.getNodeKey(_ctx.node),
    onClick: _cache[2] || (_cache[2] = withModifiers((...args) => _ctx.handleClick && _ctx.handleClick(...args), ["stop"])),
    onContextmenu: _cache[3] || (_cache[3] = (...args) => _ctx.handleContextMenu && _ctx.handleContextMenu(...args)),
    onDragstart: _cache[4] || (_cache[4] = withModifiers((...args) => _ctx.handleDragStart && _ctx.handleDragStart(...args), ["stop"])),
    onDragover: _cache[5] || (_cache[5] = withModifiers((...args) => _ctx.handleDragOver && _ctx.handleDragOver(...args), ["stop"])),
    onDragend: _cache[6] || (_cache[6] = withModifiers((...args) => _ctx.handleDragEnd && _ctx.handleDragEnd(...args), ["stop"])),
    onDrop: _cache[7] || (_cache[7] = withModifiers((...args) => _ctx.handleDrop && _ctx.handleDrop(...args), ["stop"]))
  }, [
    createElementVNode(
      "div",
      {
        class: normalizeClass(_ctx.ns.be("node", "content")),
        style: normalizeStyle({ paddingLeft: (_ctx.node.level - 1) * _ctx.tree.props.indent + "px" })
      },
      [
        _ctx.tree.props.icon || _ctx.CaretRight ? (openBlock(), createBlock(_component_el_icon, {
          key: 0,
          class: normalizeClass([
            _ctx.ns.be("node", "expand-icon"),
            _ctx.ns.is("leaf", _ctx.node.isLeaf),
            {
              expanded: !_ctx.node.isLeaf && _ctx.expanded
            }
          ]),
          onClick: withModifiers(_ctx.handleExpandIconClick, ["stop"])
        }, {
          default: withCtx(() => [
            (openBlock(), createBlock(resolveDynamicComponent(_ctx.tree.props.icon || _ctx.CaretRight)))
          ]),
          _: 1
        }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true),
        _ctx.showCheckbox ? (openBlock(), createBlock(_component_el_checkbox, {
          key: 1,
          "model-value": _ctx.node.checked,
          indeterminate: _ctx.node.indeterminate,
          disabled: !!_ctx.node.disabled,
          onClick: _cache[0] || (_cache[0] = withModifiers(() => {
          }, ["stop"])),
          onChange: _ctx.handleCheckChange
        }, null, 8, ["model-value", "indeterminate", "disabled", "onChange"])) : createCommentVNode("v-if", true),
        _ctx.node.loading ? (openBlock(), createBlock(_component_el_icon, {
          key: 2,
          class: normalizeClass([_ctx.ns.be("node", "loading-icon"), _ctx.ns.is("loading")])
        }, {
          default: withCtx(() => [
            createVNode(_component_loading)
          ]),
          _: 1
        }, 8, ["class"])) : createCommentVNode("v-if", true),
        createVNode(_component_node_content, {
          node: _ctx.node,
          "render-content": _ctx.renderContent
        }, null, 8, ["node", "render-content"])
      ],
      6
    ),
    createVNode(_component_el_collapse_transition, null, {
      default: withCtx(() => [
        !_ctx.renderAfterExpand || _ctx.childNodeRendered ? withDirectives((openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(_ctx.ns.be("node", "children")),
          role: "group",
          "aria-expanded": _ctx.expanded,
          onClick: _cache[1] || (_cache[1] = withModifiers(() => {
          }, ["stop"]))
        }, [
          (openBlock(true), createElementBlock(
            Fragment,
            null,
            renderList(_ctx.node.childNodes, (child) => {
              return openBlock(), createBlock(_component_el_tree_node, {
                key: _ctx.getNodeKey(child),
                "render-content": _ctx.renderContent,
                "render-after-expand": _ctx.renderAfterExpand,
                "show-checkbox": _ctx.showCheckbox,
                node: child,
                accordion: _ctx.accordion,
                props: _ctx.props,
                onNodeExpand: _ctx.handleChildNodeExpand
              }, null, 8, ["render-content", "render-after-expand", "show-checkbox", "node", "accordion", "props", "onNodeExpand"]);
            }),
            128
          ))
        ], 10, _hoisted_2)), [
          [vShow, _ctx.expanded]
        ]) : createCommentVNode("v-if", true)
      ]),
      _: 1
    })
  ], 42, _hoisted_1)), [
    [vShow, _ctx.node.visible]
  ]);
}
var ElTreeNode = /* @__PURE__ */ _export_sfc$1(_sfc_main$1, [["render", _sfc_render$1], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree/src/tree-node.vue"]]);
function useKeydown({ el$ }, store) {
  const ns = useNamespace("tree");
  function canNodeFocus(treeItems, nextIndex) {
    var _a, _b;
    const currentNode = store.value.getNode(treeItems[nextIndex].dataset.key);
    return currentNode.canFocus && currentNode.visible && (((_a = currentNode.parent) == null ? void 0 : _a.expanded) || ((_b = currentNode.parent) == null ? void 0 : _b.level) === 0);
  }
  const handleKeydown = (ev) => {
    const currentItem = ev.target;
    if (!currentItem.className.includes(ns.b("node")))
      return;
    const code = getEventCode(ev);
    const treeItems = Array.from(
      el$.value.querySelectorAll(`.${ns.is("focusable")}[role=treeitem]`)
    );
    const currentIndex = treeItems.indexOf(currentItem);
    let nextIndex;
    if ([EVENT_CODE.up, EVENT_CODE.down].includes(code)) {
      ev.preventDefault();
      if (code === EVENT_CODE.up) {
        nextIndex = currentIndex === -1 ? 0 : currentIndex !== 0 ? currentIndex - 1 : treeItems.length - 1;
        const startIndex = nextIndex;
        while (true) {
          if (canNodeFocus(treeItems, nextIndex)) {
            break;
          }
          nextIndex--;
          if (nextIndex === startIndex) {
            nextIndex = -1;
            break;
          }
          if (nextIndex < 0) {
            nextIndex = treeItems.length - 1;
          }
        }
      } else {
        nextIndex = currentIndex === -1 ? 0 : currentIndex < treeItems.length - 1 ? currentIndex + 1 : 0;
        const startIndex = nextIndex;
        while (true) {
          if (canNodeFocus(treeItems, nextIndex)) {
            break;
          }
          nextIndex++;
          if (nextIndex === startIndex) {
            nextIndex = -1;
            break;
          }
          if (nextIndex >= treeItems.length) {
            nextIndex = 0;
          }
        }
      }
      nextIndex !== -1 && treeItems[nextIndex].focus();
    }
    if ([EVENT_CODE.left, EVENT_CODE.right].includes(code)) {
      ev.preventDefault();
      currentItem.click();
    }
    const hasInput = currentItem.querySelector(
      '[type="checkbox"]'
    );
    if ([EVENT_CODE.enter, EVENT_CODE.numpadEnter, EVENT_CODE.space].includes(
      code
    ) && hasInput) {
      ev.preventDefault();
      hasInput.click();
    }
  };
  useEventListener(el$, "keydown", handleKeydown);
}
const treeProps = buildProps({
  data: {
    type: definePropType(Array),
    default: () => []
  },
  emptyText: {
    type: String
  },
  renderAfterExpand: {
    type: Boolean,
    default: true
  },
  nodeKey: String,
  checkStrictly: Boolean,
  defaultExpandAll: Boolean,
  expandOnClickNode: {
    type: Boolean,
    default: true
  },
  checkOnClickNode: Boolean,
  checkOnClickLeaf: {
    type: Boolean,
    default: true
  },
  checkDescendants: Boolean,
  autoExpandParent: {
    type: Boolean,
    default: true
  },
  defaultCheckedKeys: {
    type: Array
  },
  defaultExpandedKeys: {
    type: Array
  },
  currentNodeKey: {
    type: [String, Number]
  },
  renderContent: {
    type: definePropType(Function)
  },
  showCheckbox: Boolean,
  draggable: Boolean,
  allowDrag: {
    type: definePropType(Function)
  },
  allowDrop: {
    type: definePropType(Function)
  },
  props: {
    type: Object,
    default: () => ({
      children: "children",
      label: "label",
      disabled: "disabled"
    })
  },
  lazy: Boolean,
  highlightCurrent: Boolean,
  load: {
    type: Function
  },
  filterNodeMethod: {
    type: Function
  },
  accordion: Boolean,
  indent: {
    type: Number,
    default: 18
  },
  icon: {
    type: iconPropType
  }
});
const treeEmits = {
  "check-change": (data, checked, indeterminate) => data && isBoolean$1(checked) && isBoolean$1(indeterminate),
  "current-change": (data, node) => true,
  "node-click": (data, node, nodeInstance, evt) => data && node && evt instanceof Event,
  "node-contextmenu": (evt, data, node, nodeInstance) => evt instanceof Event && data && node,
  "node-collapse": (data, node, nodeInstance) => data && node,
  "node-expand": (data, node, nodeInstance) => data && node,
  check: (data, checkedInfo) => data && checkedInfo,
  "node-drag-start": (node, evt) => node && evt,
  "node-drag-end": (draggingNode, dropNode, dropType, evt) => draggingNode && evt,
  "node-drop": (draggingNode, dropNode, dropType, evt) => draggingNode && dropNode && evt,
  "node-drag-leave": (draggingNode, oldDropNode, evt) => draggingNode && oldDropNode && evt,
  "node-drag-enter": (draggingNode, dropNode, evt) => draggingNode && dropNode && evt,
  "node-drag-over": (draggingNode, dropNode, evt) => draggingNode && dropNode && evt
};
const _sfc_main = defineComponent({
  name: "ElTree",
  components: { ElTreeNode },
  props: treeProps,
  emits: treeEmits,
  setup(props, ctx) {
    const { t: t6 } = useLocale();
    const ns = useNamespace("tree");
    const store = ref(
      new TreeStore({
        key: props.nodeKey,
        data: props.data,
        lazy: props.lazy,
        props: props.props,
        load: props.load,
        currentNodeKey: props.currentNodeKey,
        checkStrictly: props.checkStrictly,
        checkDescendants: props.checkDescendants,
        defaultCheckedKeys: props.defaultCheckedKeys,
        defaultExpandedKeys: props.defaultExpandedKeys,
        autoExpandParent: props.autoExpandParent,
        defaultExpandAll: props.defaultExpandAll,
        filterNodeMethod: props.filterNodeMethod
      })
    );
    store.value.initialize();
    const root = ref(store.value.root);
    const currentNode = ref(null);
    const el$ = ref(null);
    const dropIndicator$ = ref(null);
    const { broadcastExpanded } = useNodeExpandEventBroadcast(props);
    const { dragState } = useDragNodeHandler({
      props,
      ctx,
      el$,
      dropIndicator$,
      store
    });
    useKeydown({ el$ }, store);
    const instance = getCurrentInstance();
    const isSelectTree = computed(() => {
      let parent = instance == null ? void 0 : instance.parent;
      while (parent) {
        if (parent.type.name === "ElTreeSelect") {
          return true;
        }
        parent = parent.parent;
      }
      return false;
    });
    const isEmpty2 = computed(() => {
      const { childNodes } = root.value;
      return (!childNodes || childNodes.length === 0 || childNodes.every(({ visible }) => !visible)) && !isSelectTree.value;
    });
    watch(
      () => props.currentNodeKey,
      (newVal) => {
        store.value.setCurrentNodeKey(newVal != null ? newVal : null);
      }
    );
    watch(
      () => props.defaultCheckedKeys,
      (newVal, oldVal) => {
        if (isEqual(newVal, oldVal))
          return;
        store.value.setDefaultCheckedKey(newVal != null ? newVal : []);
      }
    );
    watch(
      () => props.defaultExpandedKeys,
      (newVal) => {
        store.value.setDefaultExpandedKeys(newVal != null ? newVal : []);
      }
    );
    watch(
      () => props.data,
      (newVal) => {
        store.value.setData(newVal);
      },
      { deep: true }
    );
    watch(
      () => props.checkStrictly,
      (newVal) => {
        store.value.checkStrictly = newVal;
      }
    );
    const filter = (value) => {
      if (!props.filterNodeMethod)
        throw new Error("[Tree] filterNodeMethod is required when filter");
      store.value.filter(value);
    };
    const getNodeKey$1 = (node) => {
      return getNodeKey(props.nodeKey, node.data);
    };
    const requireNodeKey = (methodName) => {
      if (!props.nodeKey) {
        throw new Error(`[Tree] nodeKey is required in ${methodName}`);
      }
    };
    const getNodePath = (data) => {
      requireNodeKey("getNodePath");
      const node = store.value.getNode(data);
      if (!node)
        return [];
      const path = [node.data];
      let parent = node.parent;
      while (parent && parent !== root.value) {
        path.push(parent.data);
        parent = parent.parent;
      }
      return path.reverse();
    };
    const getCheckedNodes = (leafOnly, includeHalfChecked) => {
      return store.value.getCheckedNodes(leafOnly, includeHalfChecked);
    };
    const getCheckedKeys = (leafOnly) => {
      return store.value.getCheckedKeys(leafOnly);
    };
    const getCurrentNode = () => {
      const currentNode2 = store.value.getCurrentNode();
      return currentNode2 ? currentNode2.data : null;
    };
    const getCurrentKey = () => {
      requireNodeKey("getCurrentKey");
      const currentNode2 = getCurrentNode();
      return currentNode2 ? currentNode2[props.nodeKey] : null;
    };
    const setCheckedNodes = (nodes, leafOnly) => {
      requireNodeKey("setCheckedNodes");
      store.value.setCheckedNodes(nodes, leafOnly);
    };
    const setCheckedKeys = (keys, leafOnly) => {
      requireNodeKey("setCheckedKeys");
      store.value.setCheckedKeys(keys, leafOnly);
    };
    const setChecked = (data, checked, deep) => {
      store.value.setChecked(data, checked, deep);
    };
    const getHalfCheckedNodes = () => {
      return store.value.getHalfCheckedNodes();
    };
    const getHalfCheckedKeys = () => {
      return store.value.getHalfCheckedKeys();
    };
    const setCurrentNode = (node, shouldAutoExpandParent = true) => {
      requireNodeKey("setCurrentNode");
      handleCurrentChange(store, ctx.emit, () => {
        broadcastExpanded(node);
        store.value.setUserCurrentNode(node, shouldAutoExpandParent);
      });
    };
    const setCurrentKey = (key = null, shouldAutoExpandParent = true) => {
      requireNodeKey("setCurrentKey");
      handleCurrentChange(store, ctx.emit, () => {
        broadcastExpanded();
        store.value.setCurrentNodeKey(key, shouldAutoExpandParent);
      });
    };
    const getNode = (data) => {
      return store.value.getNode(data);
    };
    const remove = (data) => {
      store.value.remove(data);
    };
    const append = (data, parentNode) => {
      store.value.append(data, parentNode);
    };
    const insertBefore = (data, refNode) => {
      store.value.insertBefore(data, refNode);
    };
    const insertAfter = (data, refNode) => {
      store.value.insertAfter(data, refNode);
    };
    const handleNodeExpand = (nodeData, node, instance2) => {
      broadcastExpanded(node);
      ctx.emit("node-expand", nodeData, node, instance2);
    };
    const updateKeyChildren = (key, data) => {
      requireNodeKey("updateKeyChild");
      store.value.updateChildren(key, data);
    };
    provide(ROOT_TREE_INJECTION_KEY, {
      ctx,
      props,
      store,
      root,
      currentNode,
      instance
    });
    provide(formItemContextKey, void 0);
    return {
      ns,
      store,
      root,
      currentNode,
      dragState,
      el$,
      dropIndicator$,
      isEmpty: isEmpty2,
      filter,
      getNodeKey: getNodeKey$1,
      getNodePath,
      getCheckedNodes,
      getCheckedKeys,
      getCurrentNode,
      getCurrentKey,
      setCheckedNodes,
      setCheckedKeys,
      setChecked,
      getHalfCheckedNodes,
      getHalfCheckedKeys,
      setCurrentNode,
      setCurrentKey,
      t: t6,
      getNode,
      remove,
      append,
      insertBefore,
      insertAfter,
      handleNodeExpand,
      updateKeyChildren
    };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_tree_node = resolveComponent("el-tree-node");
  return openBlock(), createElementBlock(
    "div",
    {
      ref: "el$",
      class: normalizeClass([
        _ctx.ns.b(),
        _ctx.ns.is("dragging", !!_ctx.dragState.draggingNode),
        _ctx.ns.is("drop-not-allow", !_ctx.dragState.allowDrop),
        _ctx.ns.is("drop-inner", _ctx.dragState.dropType === "inner"),
        { [_ctx.ns.m("highlight-current")]: _ctx.highlightCurrent }
      ]),
      role: "tree"
    },
    [
      (openBlock(true), createElementBlock(
        Fragment,
        null,
        renderList(_ctx.root.childNodes, (child) => {
          return openBlock(), createBlock(_component_el_tree_node, {
            key: _ctx.getNodeKey(child),
            node: child,
            props: _ctx.props,
            accordion: _ctx.accordion,
            "render-after-expand": _ctx.renderAfterExpand,
            "show-checkbox": _ctx.showCheckbox,
            "render-content": _ctx.renderContent,
            onNodeExpand: _ctx.handleNodeExpand
          }, null, 8, ["node", "props", "accordion", "render-after-expand", "show-checkbox", "render-content", "onNodeExpand"]);
        }),
        128
      )),
      _ctx.isEmpty ? (openBlock(), createElementBlock(
        "div",
        {
          key: 0,
          class: normalizeClass(_ctx.ns.e("empty-block"))
        },
        [
          renderSlot(_ctx.$slots, "empty", {}, () => {
            var _a;
            return [
              createElementVNode(
                "span",
                {
                  class: normalizeClass(_ctx.ns.e("empty-text"))
                },
                toDisplayString((_a = _ctx.emptyText) != null ? _a : _ctx.t("el.tree.emptyText")),
                3
              )
            ];
          })
        ],
        2
      )) : createCommentVNode("v-if", true),
      withDirectives(createElementVNode(
        "div",
        {
          ref: "dropIndicator$",
          class: normalizeClass(_ctx.ns.e("drop-indicator"))
        },
        null,
        2
      ), [
        [vShow, _ctx.dragState.showDropIndicator]
      ])
    ],
    2
  );
}
var Tree = /* @__PURE__ */ _export_sfc$1(_sfc_main, [["render", _sfc_render], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree/src/tree.vue"]]);
withInstall(Tree);
buildProps({
  zIndex: {
    type: Number,
    default: 9
  },
  rotate: {
    type: Number,
    default: -22
  },
  width: Number,
  height: Number,
  image: String,
  content: {
    type: definePropType([String, Array]),
    default: "Element Plus"
  },
  font: {
    type: definePropType(Object)
  },
  gap: {
    type: definePropType(Array),
    default: () => [100, 100]
  },
  offset: {
    type: definePropType(Array)
  }
});
const tourStrategies = ["absolute", "fixed"];
const tourPlacements = [
  "top-start",
  "top-end",
  "top",
  "bottom-start",
  "bottom-end",
  "bottom",
  "left-start",
  "left-end",
  "left",
  "right-start",
  "right-end",
  "right"
];
const tourContentProps = buildProps({
  placement: {
    type: definePropType(String),
    values: tourPlacements,
    default: "bottom"
  },
  reference: {
    type: definePropType(Object),
    default: null
  },
  strategy: {
    type: definePropType(String),
    values: tourStrategies,
    default: "absolute"
  },
  offset: {
    type: Number,
    default: 10
  },
  showArrow: Boolean,
  zIndex: {
    type: Number,
    default: 2001
  }
});
buildProps({
  modelValue: Boolean,
  current: {
    type: Number,
    default: 0
  },
  showArrow: {
    type: Boolean,
    default: true
  },
  showClose: {
    type: Boolean,
    default: true
  },
  closeIcon: {
    type: iconPropType
  },
  placement: tourContentProps.placement,
  contentStyle: {
    type: definePropType([Object])
  },
  mask: {
    type: definePropType([Boolean, Object]),
    default: true
  },
  gap: {
    type: definePropType(Object),
    default: () => ({
      offset: 6,
      radius: 2
    })
  },
  zIndex: {
    type: Number
  },
  scrollIntoViewOptions: {
    type: definePropType([Boolean, Object]),
    default: () => ({
      block: "center"
    })
  },
  type: {
    type: definePropType(String)
  },
  appendTo: {
    type: teleportProps.to.type,
    default: "body"
  },
  closeOnPressEscape: {
    type: Boolean,
    default: true
  },
  targetAreaClickable: {
    type: Boolean,
    default: true
  }
});
buildProps({
  target: {
    type: definePropType([String, Object, Function])
  },
  title: String,
  description: String,
  showClose: {
    type: Boolean,
    default: void 0
  },
  closeIcon: {
    type: iconPropType
  },
  showArrow: {
    type: Boolean,
    default: void 0
  },
  placement: tourContentProps.placement,
  mask: {
    type: definePropType([Boolean, Object]),
    default: void 0
  },
  contentStyle: {
    type: definePropType([Object])
  },
  prevButtonProps: {
    type: definePropType(Object)
  },
  nextButtonProps: {
    type: definePropType(Object)
  },
  scrollIntoViewOptions: {
    type: definePropType([Boolean, Object]),
    default: void 0
  },
  type: {
    type: definePropType(String)
  }
});
buildProps({
  container: {
    type: definePropType([
      String,
      Object
    ])
  },
  offset: {
    type: Number,
    default: 0
  },
  bound: {
    type: Number,
    default: 15
  },
  duration: {
    type: Number,
    default: 300
  },
  marker: {
    type: Boolean,
    default: true
  },
  type: {
    type: definePropType(String),
    default: "default"
  },
  direction: {
    type: definePropType(String),
    default: "vertical"
  },
  selectScrollTop: Boolean
});
const defaultProps = {
  label: "label",
  value: "value",
  disabled: "disabled"
};
buildProps({
  direction: {
    type: definePropType(String),
    default: "horizontal"
  },
  options: {
    type: definePropType(Array),
    default: () => []
  },
  modelValue: {
    type: [String, Number, Boolean],
    default: void 0
  },
  props: {
    type: definePropType(Object),
    default: () => defaultProps
  },
  block: Boolean,
  size: useSizeProp,
  disabled: {
    type: Boolean,
    default: void 0
  },
  validateEvent: {
    type: Boolean,
    default: true
  },
  id: String,
  name: String,
  ...useAriaProps(["ariaLabel"])
});
const filterOption = (pattern, option) => {
  const lowerCase = pattern.toLowerCase();
  const label = option.label || option.value || "";
  return label.toLowerCase().includes(lowerCase);
};
buildProps({
  ...inputProps,
  options: {
    type: definePropType(Array),
    default: () => []
  },
  prefix: {
    type: definePropType([String, Array]),
    default: "@",
    validator: (val) => {
      if (isString(val))
        return val.length === 1;
      return val.every((v6) => isString(v6) && v6.length === 1);
    }
  },
  split: {
    type: String,
    default: " ",
    validator: (val) => val.length === 1
  },
  filterOption: {
    type: definePropType([Boolean, Function]),
    default: () => filterOption,
    validator: (val) => {
      if (val === false)
        return true;
      return isFunction(val);
    }
  },
  placement: {
    type: definePropType(String),
    default: "bottom"
  },
  showArrow: Boolean,
  offset: {
    type: Number,
    default: 0
  },
  whole: Boolean,
  checkIsWhole: {
    type: definePropType(
      Function
    )
  },
  modelValue: String,
  loading: Boolean,
  popperClass: useTooltipContentProps.popperClass,
  popperStyle: useTooltipContentProps.popperStyle,
  popperOptions: {
    type: definePropType(Object),
    default: () => ({})
  },
  props: {
    type: definePropType(Object),
    default: () => mentionDefaultProps
  }
});
const mentionDefaultProps = {
  value: "value",
  label: "label",
  disabled: "disabled"
};
buildProps({
  layout: {
    type: String,
    default: "horizontal",
    values: ["horizontal", "vertical"]
  },
  lazy: Boolean
});
buildProps({
  min: {
    type: [String, Number]
  },
  max: {
    type: [String, Number]
  },
  size: {
    type: [String, Number]
  },
  resizable: {
    type: Boolean,
    default: true
  },
  collapsible: Boolean
});
const notificationTypes = [
  "primary",
  "success",
  "info",
  "warning",
  "error"
];
buildProps({
  customClass: {
    type: String,
    default: ""
  },
  dangerouslyUseHTMLString: Boolean,
  duration: {
    type: Number,
    default: 4500
  },
  icon: {
    type: iconPropType
  },
  id: {
    type: String,
    default: ""
  },
  message: {
    type: definePropType([
      String,
      Object,
      Function
    ]),
    default: ""
  },
  offset: {
    type: Number,
    default: 0
  },
  onClick: {
    type: definePropType(Function),
    default: () => void 0
  },
  onClose: {
    type: definePropType(Function),
    required: true
  },
  position: {
    type: String,
    values: ["top-right", "top-left", "bottom-right", "bottom-left"],
    default: "top-right"
  },
  showClose: {
    type: Boolean,
    default: true
  },
  title: {
    type: String,
    default: ""
  },
  type: {
    type: String,
    values: [...notificationTypes, ""],
    default: ""
  },
  zIndex: Number,
  closeIcon: {
    type: iconPropType,
    default: close_default
  }
});

export { BAR_MAP, CASCADER_PANEL_INJECTION_KEY, CHANGE_EVENT, CommonProps, DefaultProps, DynamicSizeGrid, EVENT_CODE, ElCheckbox, ElCollapseTransition, ElEmpty, ElIcon, ElPopoverDirective, ElRadio, ElScrollbar, ElText, ElTooltip, FixedSizeGrid, NODE_INSTANCE_INJECTION_KEY, ROOT_TREE_INJECTION_KEY, TIMELINE_INJECTION_KEY, TREE_NODE_MAP_INJECTION_KEY, Alignment as TableV2Alignment, FixedDir as TableV2FixedDir, placeholderSign as TableV2Placeholder, SortOrder as TableV2SortOrder, UPDATE_MODEL_EVENT, cascaderPanelEmits, cascaderPanelProps, componentSizes, defaultProps, dropdownProps, formItemContextKey, inputProps, mentionDefaultProps, notificationTypes, popoverEmits, popoverProps, spaceItemProps, spaceProps, tableV2Props, tableV2RowProps, tagProps, textProps, timelineProps, tourContentProps, tourPlacements, tourStrategies, treeEmits, treeProps, useAriaProps, useCascaderConfig, useEmptyValuesProps, useFormSize, useId, useLocale, useNamespace, useSizeProp, useSpace, useTooltipContentProps, useTooltipTriggerProps, virtualizedGridProps, virtualizedListProps, virtualizedProps, virtualizedScrollbarProps };
//# sourceMappingURL=index-DfyAzYq5.mjs.map
