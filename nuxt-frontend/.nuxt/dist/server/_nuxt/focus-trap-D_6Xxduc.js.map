{"version":3,"file":"focus-trap-D_6Xxduc.js","sources":["../../../../node_modules/element-plus/es/components/teleport/src/teleport.mjs","../../../../node_modules/element-plus/es/components/teleport/src/teleport2.mjs","../../../../node_modules/element-plus/es/components/teleport/index.mjs","../../../../node_modules/element-plus/es/components/focus-trap/src/tokens.mjs","../../../../node_modules/element-plus/es/components/focus-trap/src/utils.mjs","../../../../node_modules/element-plus/es/components/focus-trap/src/focus-trap.mjs"],"sourcesContent":["import { buildProps, definePropType } from '../../../utils/vue/props/runtime.mjs';\n\nconst teleportProps = buildProps({\n  to: {\n    type: definePropType([String, Object]),\n    required: true\n  },\n  disabled: Boolean\n});\n\nexport { teleportProps };\n//# sourceMappingURL=teleport.mjs.map\n","import { defineComponent, renderSlot, openBlock, createBlock, Teleport as Teleport$1 } from 'vue';\nimport { teleportProps } from './teleport.mjs';\nimport _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';\n\nconst _sfc_main = defineComponent({\n  __name: \"teleport\",\n  props: teleportProps,\n  setup(__props) {\n    return (_ctx, _cache) => {\n      return _ctx.disabled ? renderSlot(_ctx.$slots, \"default\", { key: 0 }) : (openBlock(), createBlock(Teleport$1, {\n        key: 1,\n        to: _ctx.to\n      }, [\n        renderSlot(_ctx.$slots, \"default\")\n      ], 8, [\"to\"]));\n    };\n  }\n});\nvar Teleport = /* @__PURE__ */ _export_sfc(_sfc_main, [[\"__file\", \"/home/runner/work/element-plus/element-plus/packages/components/teleport/src/teleport.vue\"]]);\n\nexport { Teleport as default };\n//# sourceMappingURL=teleport2.mjs.map\n","import Teleport from './src/teleport2.mjs';\nexport { teleportProps } from './src/teleport.mjs';\nimport { withInstall } from '../../utils/vue/install.mjs';\n\nconst ElTeleport = withInstall(Teleport);\n\nexport { ElTeleport, ElTeleport as default };\n//# sourceMappingURL=index.mjs.map\n","const FOCUS_AFTER_TRAPPED = \"focus-trap.focus-after-trapped\";\nconst FOCUS_AFTER_RELEASED = \"focus-trap.focus-after-released\";\nconst FOCUSOUT_PREVENTED = \"focus-trap.focusout-prevented\";\nconst FOCUS_AFTER_TRAPPED_OPTS = {\n  cancelable: true,\n  bubbles: false\n};\nconst FOCUSOUT_PREVENTED_OPTS = {\n  cancelable: true,\n  bubbles: false\n};\nconst ON_TRAP_FOCUS_EVT = \"focusAfterTrapped\";\nconst ON_RELEASE_FOCUS_EVT = \"focusAfterReleased\";\nconst FOCUS_TRAP_INJECTION_KEY = Symbol(\"elFocusTrap\");\n\nexport { FOCUSOUT_PREVENTED, FOCUSOUT_PREVENTED_OPTS, FOCUS_AFTER_RELEASED, FOCUS_AFTER_TRAPPED, FOCUS_AFTER_TRAPPED_OPTS, FOCUS_TRAP_INJECTION_KEY, ON_RELEASE_FOCUS_EVT, ON_TRAP_FOCUS_EVT };\n//# sourceMappingURL=tokens.mjs.map\n","import { ref, onMounted, onBeforeUnmount } from 'vue';\nimport { FOCUSOUT_PREVENTED, FOCUSOUT_PREVENTED_OPTS } from './tokens.mjs';\nimport { focusElement } from '../../../utils/dom/aria.mjs';\n\nconst focusReason = ref();\nconst lastUserFocusTimestamp = ref(0);\nconst lastAutomatedFocusTimestamp = ref(0);\nlet focusReasonUserCount = 0;\nconst obtainAllFocusableElements = (element) => {\n  const nodes = [];\n  const walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (node) => {\n      const isHiddenInput = node.tagName === \"INPUT\" && node.type === \"hidden\";\n      if (node.disabled || node.hidden || isHiddenInput)\n        return NodeFilter.FILTER_SKIP;\n      return node.tabIndex >= 0 || node === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n  while (walker.nextNode())\n    nodes.push(walker.currentNode);\n  return nodes;\n};\nconst getVisibleElement = (elements, container) => {\n  for (const element of elements) {\n    if (!isHidden(element, container))\n      return element;\n  }\n};\nconst isHidden = (element, container) => {\n  if (process.env.NODE_ENV === \"test\")\n    return false;\n  if (getComputedStyle(element).visibility === \"hidden\")\n    return true;\n  while (element) {\n    if (container && element === container)\n      return false;\n    if (getComputedStyle(element).display === \"none\")\n      return true;\n    element = element.parentElement;\n  }\n  return false;\n};\nconst getEdges = (container) => {\n  const focusable = obtainAllFocusableElements(container);\n  const first = getVisibleElement(focusable, container);\n  const last = getVisibleElement(focusable.reverse(), container);\n  return [first, last];\n};\nconst isSelectable = (element) => {\n  return element instanceof HTMLInputElement && \"select\" in element;\n};\nconst tryFocus = (element, shouldSelect) => {\n  if (element) {\n    const prevFocusedElement = document.activeElement;\n    focusElement(element, { preventScroll: true });\n    lastAutomatedFocusTimestamp.value = window.performance.now();\n    if (element !== prevFocusedElement && isSelectable(element) && shouldSelect) {\n      element.select();\n    }\n  }\n};\nfunction removeFromStack(list, item) {\n  const copy = [...list];\n  const idx = list.indexOf(item);\n  if (idx !== -1) {\n    copy.splice(idx, 1);\n  }\n  return copy;\n}\nconst createFocusableStack = () => {\n  let stack = [];\n  const push = (layer) => {\n    const currentLayer = stack[0];\n    if (currentLayer && layer !== currentLayer) {\n      currentLayer.pause();\n    }\n    stack = removeFromStack(stack, layer);\n    stack.unshift(layer);\n  };\n  const remove = (layer) => {\n    var _a, _b;\n    stack = removeFromStack(stack, layer);\n    (_b = (_a = stack[0]) == null ? void 0 : _a.resume) == null ? void 0 : _b.call(_a);\n  };\n  return {\n    push,\n    remove\n  };\n};\nconst focusFirstDescendant = (elements, shouldSelect = false) => {\n  const prevFocusedElement = document.activeElement;\n  for (const element of elements) {\n    tryFocus(element, shouldSelect);\n    if (document.activeElement !== prevFocusedElement)\n      return;\n  }\n};\nconst focusableStack = createFocusableStack();\nconst isFocusCausedByUserEvent = () => {\n  return lastUserFocusTimestamp.value > lastAutomatedFocusTimestamp.value;\n};\nconst notifyFocusReasonPointer = () => {\n  focusReason.value = \"pointer\";\n  lastUserFocusTimestamp.value = window.performance.now();\n};\nconst notifyFocusReasonKeydown = () => {\n  focusReason.value = \"keyboard\";\n  lastUserFocusTimestamp.value = window.performance.now();\n};\nconst useFocusReason = () => {\n  onMounted(() => {\n    if (focusReasonUserCount === 0) {\n      document.addEventListener(\"mousedown\", notifyFocusReasonPointer);\n      document.addEventListener(\"touchstart\", notifyFocusReasonPointer);\n      document.addEventListener(\"keydown\", notifyFocusReasonKeydown);\n    }\n    focusReasonUserCount++;\n  });\n  onBeforeUnmount(() => {\n    focusReasonUserCount--;\n    if (focusReasonUserCount <= 0) {\n      document.removeEventListener(\"mousedown\", notifyFocusReasonPointer);\n      document.removeEventListener(\"touchstart\", notifyFocusReasonPointer);\n      document.removeEventListener(\"keydown\", notifyFocusReasonKeydown);\n    }\n  });\n  return {\n    focusReason,\n    lastUserFocusTimestamp,\n    lastAutomatedFocusTimestamp\n  };\n};\nconst createFocusOutPreventedEvent = (detail) => {\n  return new CustomEvent(FOCUSOUT_PREVENTED, {\n    ...FOCUSOUT_PREVENTED_OPTS,\n    detail\n  });\n};\n\nexport { createFocusOutPreventedEvent, focusFirstDescendant, focusableStack, getEdges, getVisibleElement, isFocusCausedByUserEvent, isHidden, obtainAllFocusableElements, tryFocus, useFocusReason };\n//# sourceMappingURL=utils.mjs.map\n","import { defineComponent, ref, provide, watch, unref, onMounted, onBeforeUnmount, nextTick, renderSlot } from 'vue';\nimport { isNil } from 'lodash-unified';\nimport { useFocusReason, tryFocus, createFocusOutPreventedEvent, getEdges, focusableStack, focusFirstDescendant, obtainAllFocusableElements, isFocusCausedByUserEvent } from './utils.mjs';\nimport { ON_TRAP_FOCUS_EVT, ON_RELEASE_FOCUS_EVT, FOCUS_TRAP_INJECTION_KEY, FOCUS_AFTER_TRAPPED, FOCUS_AFTER_TRAPPED_OPTS, FOCUS_AFTER_RELEASED } from './tokens.mjs';\nimport _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';\nimport { useEscapeKeydown } from '../../../hooks/use-escape-keydown/index.mjs';\nimport { getEventCode } from '../../../utils/dom/event.mjs';\nimport { EVENT_CODE } from '../../../constants/aria.mjs';\nimport { isString } from '@vue/shared';\n\nconst _sfc_main = defineComponent({\n  name: \"ElFocusTrap\",\n  inheritAttrs: false,\n  props: {\n    loop: Boolean,\n    trapped: Boolean,\n    focusTrapEl: Object,\n    focusStartEl: {\n      type: [Object, String],\n      default: \"first\"\n    }\n  },\n  emits: [\n    ON_TRAP_FOCUS_EVT,\n    ON_RELEASE_FOCUS_EVT,\n    \"focusin\",\n    \"focusout\",\n    \"focusout-prevented\",\n    \"release-requested\"\n  ],\n  setup(props, { emit }) {\n    const forwardRef = ref();\n    let lastFocusBeforeTrapped;\n    let lastFocusAfterTrapped;\n    const { focusReason } = useFocusReason();\n    useEscapeKeydown((event) => {\n      if (props.trapped && !focusLayer.paused) {\n        emit(\"release-requested\", event);\n      }\n    });\n    const focusLayer = {\n      paused: false,\n      pause() {\n        this.paused = true;\n      },\n      resume() {\n        this.paused = false;\n      }\n    };\n    const onKeydown = (e) => {\n      if (!props.loop && !props.trapped)\n        return;\n      if (focusLayer.paused)\n        return;\n      const { altKey, ctrlKey, metaKey, currentTarget, shiftKey } = e;\n      const { loop } = props;\n      const code = getEventCode(e);\n      const isTabbing = code === EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey;\n      const currentFocusingEl = document.activeElement;\n      if (isTabbing && currentFocusingEl) {\n        const container = currentTarget;\n        const [first, last] = getEdges(container);\n        const isTabbable = first && last;\n        if (!isTabbable) {\n          if (currentFocusingEl === container) {\n            const focusoutPreventedEvent = createFocusOutPreventedEvent({\n              focusReason: focusReason.value\n            });\n            emit(\"focusout-prevented\", focusoutPreventedEvent);\n            if (!focusoutPreventedEvent.defaultPrevented) {\n              e.preventDefault();\n            }\n          }\n        } else {\n          if (!shiftKey && currentFocusingEl === last) {\n            const focusoutPreventedEvent = createFocusOutPreventedEvent({\n              focusReason: focusReason.value\n            });\n            emit(\"focusout-prevented\", focusoutPreventedEvent);\n            if (!focusoutPreventedEvent.defaultPrevented) {\n              e.preventDefault();\n              if (loop)\n                tryFocus(first, true);\n            }\n          } else if (shiftKey && [first, container].includes(currentFocusingEl)) {\n            const focusoutPreventedEvent = createFocusOutPreventedEvent({\n              focusReason: focusReason.value\n            });\n            emit(\"focusout-prevented\", focusoutPreventedEvent);\n            if (!focusoutPreventedEvent.defaultPrevented) {\n              e.preventDefault();\n              if (loop)\n                tryFocus(last, true);\n            }\n          }\n        }\n      }\n    };\n    provide(FOCUS_TRAP_INJECTION_KEY, {\n      focusTrapRef: forwardRef,\n      onKeydown\n    });\n    watch(\n      () => props.focusTrapEl,\n      (focusTrapEl) => {\n        if (focusTrapEl) {\n          forwardRef.value = focusTrapEl;\n        }\n      },\n      { immediate: true }\n    );\n    watch([forwardRef], ([forwardRef2], [oldForwardRef]) => {\n      if (forwardRef2) {\n        forwardRef2.addEventListener(\"keydown\", onKeydown);\n        forwardRef2.addEventListener(\"focusin\", onFocusIn);\n        forwardRef2.addEventListener(\"focusout\", onFocusOut);\n      }\n      if (oldForwardRef) {\n        oldForwardRef.removeEventListener(\"keydown\", onKeydown);\n        oldForwardRef.removeEventListener(\"focusin\", onFocusIn);\n        oldForwardRef.removeEventListener(\"focusout\", onFocusOut);\n      }\n    });\n    const trapOnFocus = (e) => {\n      emit(ON_TRAP_FOCUS_EVT, e);\n    };\n    const releaseOnFocus = (e) => emit(ON_RELEASE_FOCUS_EVT, e);\n    const onFocusIn = (e) => {\n      const trapContainer = unref(forwardRef);\n      if (!trapContainer)\n        return;\n      const target = e.target;\n      const relatedTarget = e.relatedTarget;\n      const isFocusedInTrap = target && trapContainer.contains(target);\n      if (!props.trapped) {\n        const isPrevFocusedInTrap = relatedTarget && trapContainer.contains(relatedTarget);\n        if (!isPrevFocusedInTrap) {\n          lastFocusBeforeTrapped = relatedTarget;\n        }\n      }\n      if (isFocusedInTrap)\n        emit(\"focusin\", e);\n      if (focusLayer.paused)\n        return;\n      if (props.trapped) {\n        if (isFocusedInTrap) {\n          lastFocusAfterTrapped = target;\n        } else {\n          tryFocus(lastFocusAfterTrapped, true);\n        }\n      }\n    };\n    const onFocusOut = (e) => {\n      const trapContainer = unref(forwardRef);\n      if (focusLayer.paused || !trapContainer)\n        return;\n      if (props.trapped) {\n        const relatedTarget = e.relatedTarget;\n        if (!isNil(relatedTarget) && !trapContainer.contains(relatedTarget)) {\n          setTimeout(() => {\n            if (!focusLayer.paused && props.trapped) {\n              const focusoutPreventedEvent = createFocusOutPreventedEvent({\n                focusReason: focusReason.value\n              });\n              emit(\"focusout-prevented\", focusoutPreventedEvent);\n              if (!focusoutPreventedEvent.defaultPrevented) {\n                tryFocus(lastFocusAfterTrapped, true);\n              }\n            }\n          }, 0);\n        }\n      } else {\n        const target = e.target;\n        const isFocusedInTrap = target && trapContainer.contains(target);\n        if (!isFocusedInTrap)\n          emit(\"focusout\", e);\n      }\n    };\n    async function startTrap() {\n      await nextTick();\n      const trapContainer = unref(forwardRef);\n      if (trapContainer) {\n        focusableStack.push(focusLayer);\n        const prevFocusedElement = trapContainer.contains(\n          document.activeElement\n        ) ? lastFocusBeforeTrapped : document.activeElement;\n        lastFocusBeforeTrapped = prevFocusedElement;\n        const isPrevFocusContained = trapContainer.contains(prevFocusedElement);\n        if (!isPrevFocusContained) {\n          const focusEvent = new Event(\n            FOCUS_AFTER_TRAPPED,\n            FOCUS_AFTER_TRAPPED_OPTS\n          );\n          trapContainer.addEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);\n          trapContainer.dispatchEvent(focusEvent);\n          if (!focusEvent.defaultPrevented) {\n            nextTick(() => {\n              let focusStartEl = props.focusStartEl;\n              if (!isString(focusStartEl)) {\n                tryFocus(focusStartEl);\n                if (document.activeElement !== focusStartEl) {\n                  focusStartEl = \"first\";\n                }\n              }\n              if (focusStartEl === \"first\") {\n                focusFirstDescendant(\n                  obtainAllFocusableElements(trapContainer),\n                  true\n                );\n              }\n              if (document.activeElement === prevFocusedElement || focusStartEl === \"container\") {\n                tryFocus(trapContainer);\n              }\n            });\n          }\n        }\n      }\n    }\n    function stopTrap() {\n      const trapContainer = unref(forwardRef);\n      if (trapContainer) {\n        trapContainer.removeEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);\n        const releasedEvent = new CustomEvent(FOCUS_AFTER_RELEASED, {\n          ...FOCUS_AFTER_TRAPPED_OPTS,\n          detail: {\n            focusReason: focusReason.value\n          }\n        });\n        trapContainer.addEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);\n        trapContainer.dispatchEvent(releasedEvent);\n        if (!releasedEvent.defaultPrevented && (focusReason.value == \"keyboard\" || !isFocusCausedByUserEvent() || trapContainer.contains(document.activeElement))) {\n          tryFocus(lastFocusBeforeTrapped != null ? lastFocusBeforeTrapped : document.body);\n        }\n        trapContainer.removeEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);\n        focusableStack.remove(focusLayer);\n        lastFocusBeforeTrapped = null;\n        lastFocusAfterTrapped = null;\n      }\n    }\n    onMounted(() => {\n      if (props.trapped) {\n        startTrap();\n      }\n      watch(\n        () => props.trapped,\n        (trapped) => {\n          if (trapped) {\n            startTrap();\n          } else {\n            stopTrap();\n          }\n        }\n      );\n    });\n    onBeforeUnmount(() => {\n      if (props.trapped) {\n        stopTrap();\n      }\n      if (forwardRef.value) {\n        forwardRef.value.removeEventListener(\"keydown\", onKeydown);\n        forwardRef.value.removeEventListener(\"focusin\", onFocusIn);\n        forwardRef.value.removeEventListener(\"focusout\", onFocusOut);\n        forwardRef.value = void 0;\n      }\n      lastFocusBeforeTrapped = null;\n      lastFocusAfterTrapped = null;\n    });\n    return {\n      onKeydown\n    };\n  }\n});\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return renderSlot(_ctx.$slots, \"default\", { handleKeydown: _ctx.onKeydown });\n}\nvar ElFocusTrap = /* @__PURE__ */ _export_sfc(_sfc_main, [[\"render\", _sfc_render], [\"__file\", \"/home/runner/work/element-plus/element-plus/packages/components/focus-trap/src/focus-trap.vue\"]]);\n\nexport { ElFocusTrap as default };\n//# sourceMappingURL=focus-trap.mjs.map\n"],"names":["_sfc_main","focusReason"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5]}