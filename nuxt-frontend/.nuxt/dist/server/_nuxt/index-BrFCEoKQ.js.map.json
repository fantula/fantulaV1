{"file":"index-BrFCEoKQ.js","mappings":";;AAGA,MAAM,qBAAqB,CAAC,IAAI,oBAAoB,aAAa;AAC/D,QAAM,QAAQ,gBAAgB,GAAG,OAAO,EAAE;AAAA,IACxC,CAAC,MAAM;AACL,UAAI;AACJ,aAAO,QAAQ,CAAC,OAAO,KAAK,EAAE,SAAS,OAAO,SAAS,GAAG,UAAU,sBAAsB,CAAC,CAAC,EAAE;AAAA,IAChG;AAAA,EACJ;AACE,QAAM,OAAO,MAAM,IAAI,CAAC,MAAM,EAAE,UAAU,GAAG;AAC7C,SAAO,KAAK,IAAI,CAAC,QAAQ,SAAS,GAAG,CAAC,EAAE,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC;AAC3D;AACK,MAAC,qBAAqB,CAAC,IAAI,uBAAuB;AACrD,QAAM,WAAW,WAAW,EAAE;AAC9B,QAAM,kBAAkB,WAAW,EAAE;AACrC,QAAM,WAA2B,oBAAI,QAAO;AAC5C,QAAM,WAAW,CAAC,UAAU;AAC1B,aAAS,MAAM,MAAM,GAAG,IAAI;AAC5B,eAAW,QAAQ;AAAA,EAgBrB;AACA,QAAM,cAAc,CAAC,UAAU;AAC7B,WAAO,SAAS,MAAM,MAAM,GAAG;AAC/B,eAAW,QAAQ;AACnB,UAAM,YAAY,MAAM,SAAQ,EAAG;AACnC,UAAM,aAAa,UAAU;AAC7B,UAAM,aAAa,SAAS,IAAI,UAAU;AAC1C,UAAM,QAAQ,WAAW,QAAQ,SAAS;AAC1C,eAAW,OAAO,OAAO,CAAC;AAAA,EAC5B;AACA,QAAM,eAAe,MAAM;AACzB,oBAAgB,QAAQ;AAAA,MACtB;AAAA,MACA;AAAA,MACA,SAAS;AAAA,IACf;AAAA,EACE;AACA,QAAM,mBAAmB,CAAC,UAAU;AAClC,WAAO,MAAM,OAAM;AAAA,EACrB;AACA,QAAM,iBAAiB,gBAAgB;AAAA,IACrC,MAAM,GAAG,EAAE,SAAS;AAClB,aAAO,MAAM;AACX,qBAAY;AACZ,eAAO,MAAM,UAAU,EAAE,kBAAkB;AAAA,UACzC,QAAQ,MAAM;AAAA,QACxB,CAAS,IAAI;AAAA,MACP;AAAA,IACF;AAAA,EACJ,CAAG;AACD,SAAO;AAAA,IACL,UAAU;AAAA,IACV;AAAA,IACA;AAAA,IACA;AAAA,EACJ;AACA;","names":[],"sources":["../../../../node_modules/element-plus/es/hooks/use-ordered-children/index.mjs"],"sourcesContent":["import { shallowRef, defineComponent, h, triggerRef, onMounted, isVNode } from 'vue';\nimport { flattedChildren } from '../../utils/vue/vnode.mjs';\n\nconst getOrderedChildren = (vm, childComponentName, children) => {\n  const nodes = flattedChildren(vm.subTree).filter(\n    (n) => {\n      var _a;\n      return isVNode(n) && ((_a = n.type) == null ? void 0 : _a.name) === childComponentName && !!n.component;\n    }\n  );\n  const uids = nodes.map((n) => n.component.uid);\n  return uids.map((uid) => children[uid]).filter((p) => !!p);\n};\nconst useOrderedChildren = (vm, childComponentName) => {\n  const children = shallowRef({});\n  const orderedChildren = shallowRef([]);\n  const nodesMap = /* @__PURE__ */ new WeakMap();\n  const addChild = (child) => {\n    children.value[child.uid] = child;\n    triggerRef(children);\n    onMounted(() => {\n      const childNode = child.getVnode().el;\n      const parentNode = childNode.parentNode;\n      if (!nodesMap.has(parentNode)) {\n        nodesMap.set(parentNode, []);\n        const originalFn = parentNode.insertBefore.bind(parentNode);\n        parentNode.insertBefore = (node, anchor) => {\n          const shouldSortChildren = nodesMap.get(parentNode).some((el) => node === el || anchor === el);\n          if (shouldSortChildren)\n            triggerRef(children);\n          return originalFn(node, anchor);\n        };\n      }\n      nodesMap.get(parentNode).push(childNode);\n    });\n  };\n  const removeChild = (child) => {\n    delete children.value[child.uid];\n    triggerRef(children);\n    const childNode = child.getVnode().el;\n    const parentNode = childNode.parentNode;\n    const childNodes = nodesMap.get(parentNode);\n    const index = childNodes.indexOf(childNode);\n    childNodes.splice(index, 1);\n  };\n  const sortChildren = () => {\n    orderedChildren.value = getOrderedChildren(\n      vm,\n      childComponentName,\n      children.value\n    );\n  };\n  const IsolatedRenderer = (props) => {\n    return props.render();\n  };\n  const ChildrenSorter = defineComponent({\n    setup(_, { slots }) {\n      return () => {\n        sortChildren();\n        return slots.default ? h(IsolatedRenderer, {\n          render: slots.default\n        }) : null;\n      };\n    }\n  });\n  return {\n    children: orderedChildren,\n    addChild,\n    removeChild,\n    ChildrenSorter\n  };\n};\n\nexport { useOrderedChildren };\n//# sourceMappingURL=index.mjs.map\n"],"version":3}